<init> 0
<init> 0
compatNewTypeName 2
<init> 0
<init> 0
compatNewTypeName 2
$init$ 0
tuple2 2
ap3 4
map3 4
tuple3 3
ap4 5
map4 5
tuple4 4
ap5 6
map5 6
tuple5 5
ap6 7
map6 7
tuple6 6
ap7 8
map7 8
tuple7 7
ap8 9
map8 9
tuple8 8
ap9 10
map9 10
tuple9 9
ap10 11
map10 11
tuple10 10
ap11 12
map11 12
tuple11 11
ap12 13
map12 13
tuple12 12
ap13 14
map13 14
tuple13 13
ap14 15
map14 15
tuple14 14
ap15 16
map15 16
tuple15 15
ap16 17
map16 17
tuple16 16
ap17 18
map17 18
tuple17 17
ap18 19
map18 19
tuple18 18
ap19 20
map19 20
tuple19 19
ap20 21
map20 21
tuple20 20
ap21 22
map21 22
tuple21 21
ap22 23
map22 23
tuple22 22
$init$ 0
parMap2 4
parMap3 5
parMap4 6
parMap5 7
parMap6 8
parMap7 9
parMap8 10
parMap9 11
parMap10 12
parMap11 13
parMap12 14
parMap13 15
parMap14 16
parMap15 17
parMap16 18
parMap17 19
parMap18 20
parMap19 21
parMap20 22
parMap21 23
parMap22 24
$init$ 0
map2 5
contramap2 5
imap2 6
tuple2 4
traverse2 6
map3 6
contramap3 6
imap3 7
tuple3 5
traverse3 7
map4 7
contramap4 7
imap4 8
tuple4 6
traverse4 8
map5 8
contramap5 8
imap5 9
tuple5 7
traverse5 9
map6 9
contramap6 9
imap6 10
tuple6 8
traverse6 10
map7 10
contramap7 10
imap7 11
tuple7 9
traverse7 11
map8 11
contramap8 11
imap8 12
tuple8 10
traverse8 12
map9 12
contramap9 12
imap9 13
tuple9 11
traverse9 13
map10 13
contramap10 13
imap10 14
tuple10 12
traverse10 14
map11 14
contramap11 14
imap11 15
tuple11 13
traverse11 15
map12 15
contramap12 15
imap12 16
tuple12 14
traverse12 16
map13 16
contramap13 16
imap13 17
tuple13 15
traverse13 17
map14 17
contramap14 17
imap14 18
tuple14 16
traverse14 18
map15 18
contramap15 18
imap15 19
tuple15 17
traverse15 19
map16 19
contramap16 19
imap16 20
tuple16 18
traverse16 20
map17 20
contramap17 20
imap17 21
tuple17 19
traverse17 21
map18 21
contramap18 21
imap18 22
tuple18 20
traverse18 22
map19 22
contramap19 22
imap19 23
tuple19 21
traverse19 23
map20 23
contramap20 23
imap20 24
tuple20 22
traverse20 24
map21 24
contramap21 24
imap21 25
tuple21 23
traverse21 25
map22 25
contramap22 25
imap22 26
tuple22 24
traverse22 26
<init> 0
$bar$at$bar 1
<init> 1
$bar$at$bar 1
apWith 2
map 2
contramap 2
imap 3
<init> 2
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 3
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 4
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 5
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 6
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 7
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 8
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 9
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 10
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 11
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 12
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 13
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 14
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 15
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 16
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 17
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 18
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 19
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 20
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 21
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 22
apWith 2
map 3
contramap 3
imap 4
tupled 2
$init$ 0
catsSyntaxTuple1Parallel 1
catsSyntaxTuple2Parallel 1
catsSyntaxTuple3Parallel 1
catsSyntaxTuple4Parallel 1
catsSyntaxTuple5Parallel 1
catsSyntaxTuple6Parallel 1
catsSyntaxTuple7Parallel 1
catsSyntaxTuple8Parallel 1
catsSyntaxTuple9Parallel 1
catsSyntaxTuple10Parallel 1
catsSyntaxTuple11Parallel 1
catsSyntaxTuple12Parallel 1
catsSyntaxTuple13Parallel 1
catsSyntaxTuple14Parallel 1
catsSyntaxTuple15Parallel 1
catsSyntaxTuple16Parallel 1
catsSyntaxTuple17Parallel 1
catsSyntaxTuple18Parallel 1
catsSyntaxTuple19Parallel 1
catsSyntaxTuple20Parallel 1
catsSyntaxTuple21Parallel 1
catsSyntaxTuple22Parallel 1
<init> 1
parMap 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
$init$ 0
catsSyntaxTuple1Semigroupal 1
catsSyntaxTuple2Semigroupal 1
catsSyntaxTuple3Semigroupal 1
catsSyntaxTuple4Semigroupal 1
catsSyntaxTuple5Semigroupal 1
catsSyntaxTuple6Semigroupal 1
catsSyntaxTuple7Semigroupal 1
catsSyntaxTuple8Semigroupal 1
catsSyntaxTuple9Semigroupal 1
catsSyntaxTuple10Semigroupal 1
catsSyntaxTuple11Semigroupal 1
catsSyntaxTuple12Semigroupal 1
catsSyntaxTuple13Semigroupal 1
catsSyntaxTuple14Semigroupal 1
catsSyntaxTuple15Semigroupal 1
catsSyntaxTuple16Semigroupal 1
catsSyntaxTuple17Semigroupal 1
catsSyntaxTuple18Semigroupal 1
catsSyntaxTuple19Semigroupal 1
catsSyntaxTuple20Semigroupal 1
catsSyntaxTuple21Semigroupal 1
catsSyntaxTuple22Semigroupal 1
<init> 1
map 2
contramap 2
imap 3
traverse 3
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
$init$ 0
unite 3
separate 3
guard 1
compose 1
$init$ 0
pure 1
unit 0
map 2
replicateA 2
compose 1
composeContravariantMonoidal 1
unlessA 2
whenA 2
<init> 0
monoid 2
catsApplicativeForArrow 1
coflatMap 1
<init> 2
empty 0
<init> 1
pure 1
map 2
ap 2
product 2
$init$ 0
raiseError 1
handleErrorWith 2
handleError 2
attempt 1
attemptT 1
recover 2
recoverWith 2
onError 2
catchNonFatal 2
catchNonFatalEval 2
fromTry 2
fromEither 1
<init> 0
apply 1
$init$ 0
ap 2
productR 2
productL 2
product 2
$less$times$greater 2
$times$greater 2
$less$times 2
followedBy 2
forEffect 2
ap2 3
map2 3
map2Eval 3
compose 1
<init> 0
semigroup 2
<init> 2
combine 2
$init$ 0
bifoldLeft 4
bifoldRight 4
bifoldMap 4
compose 1
$init$ 0
F 0
G 0
bifoldLeft 4
bifoldRight 4
$init$ 0
bimap 3
rightFunctor 0
leftFunctor 0
leftMap 2
compose 1
leftWiden 1
$init$ 0
F 0
G 0
bimap 3
<init> 0
map 2
<init> 0
map 2
$init$ 0
bitraverse 4
bisequence 2
compose 1
bimap 3
$init$ 0
F 0
G 0
bitraverse 4
$init$ 0
coflatMap 2
coflatten 1
extract 1
$init$ 0
F 0
G 0
distribute 3
$init$ 0
F 0
G 0
imap 3
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
ap 2
product 2
$init$ 0
F 0
G 0
pure 1
$init$ 0
F 0
combineK 2
$init$ 0
F 0
empty 0
F 0
$init$ 0
F 0
G 0
foldLeft 3
foldRight 3
$init$ 0
F 0
G 0
traverse 3
$init$ 0
F 0
G 0
nonEmptyTraverse 3
$init$ 0
F 0
G 0
reduceLeftTo 3
reduceRightTo 3
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
unit 0
contramap 2
product 2
$init$ 0
F 0
G 0
product 2
$init$ 0
F 0
G 0
product 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
imap 3
$init$ 0
F 0
G 0
imap 3
$init$ 0
contramap 2
imap 3
compose 1
narrow 1
liftContravariant 1
composeFunctor 1
$init$ 0
trivial 0
<init> 0
monoid 1
<init> 1
empty 0
$init$ 0
composeFunctor 1
<init> 0
semigroup 1
<init> 1
combine 2
$init$ 0
distribute 3
cosequence 2
compose 1
<init> 0
value 0
map 1
flatMap 1
memoize 0
<init> 1
memoize 0
<init> 1
memoize 0
<init> 0
apply 1
<init> 1
value 0
memoize 0
<init> 0
apply 1
<init> 0
now 1
later 1
always 1
defer 1
<init> 1
memoize 0
value 0
advance 1
advance1 1
<init> 0
memoize 0
value 0
<init> 1
memoize 0
value 0
evaluate 1
<init> 0
<init> 0
map 2
pure 1
flatMap 2
extract 1
coflatMap 2
<init> 0
foldLeft 3
foldRight 3
reduce 2
reduceLeft 2
reduceLeftTo 3
reduceRight 2
reduceRightTo 3
reduceRightOption 2
reduceRightToOption 3
size 1
catsOrderForEval 1
catsGroupForEval 1
<init> 0
catsPartialOrderForEval 1
catsMonoidForEval 1
<init> 0
catsEqForEval 1
catsSemigroupForEval 1
$init$ 0
algebra 0
combine 2
$init$ 0
algebra 0
$init$ 0
algebra 0
inverse 1
remove 2
$init$ 0
flatMap 2
flatten 1
productREval 2
followedByEval 2
productLEval 2
forEffectEval 2
ap 2
product 2
mproduct 2
ifM 3
tailRecM 2
flatTap 2
$init$ 0
foldLeft 3
foldRight 3
reduceLeftToOption 3
reduceRightToOption 3
reduceLeftOption 2
reduceRightOption 2
minimumOption 2
maximumOption 2
get 2
collectFirst 2
collectFirstSome 2
fold 2
combineAll 2
foldMap 3
foldM 4
foldLeftM 4
foldMapM 4
traverse_ 3
sequence_ 2
foldK 2
find 2
exists 2
forall 2
existsM 3
forallM 3
toList 1
partitionEither 3
filter_ 2
takeWhile_ 2
dropWhile_ 2
isEmpty 1
nonEmpty 1
intercalate 3
intersperseList 2
compose 1
unorderedFold 2
unorderedFoldMap 3
<init> 0
<init> 0
apply 1
iterateRight 3
<init> 0
uncons 0
<init> 0
<init> 0
uncons 0
cons 2
fromFoldable 2
$init$ 0
map 2
imap 3
fmap 2
widen 1
lift 1
void 1
fproduct 2
as 2
tupleLeft 2
tupleRight 2
compose 1
composeContravariant 1
<init> 0
inj 0
prj 0
apply 1
unapply 1
<init> 0
catsReflexiveInjectInstance 0
catsLeftInjectInstance 0
catsRightInjectInstance 1
<init> 0
apply 1
<init> 0
inj 0
prj 0
apply 1
unapply 1
<init> 0
catsReflexiveInjectKInstance 0
catsLeftInjectKInstance 0
catsRightInjectKInstance 1
<init> 0
apply 1
$init$ 0
imap 3
compose 1
composeFunctor 1
composeContravariant 1
<init> 0
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
$init$ 0
point 1
unit 0
<init> 0
monoid 2
<init> 2
empty 0
$init$ 0
composeApply 1
<init> 0
semigroup 2
<init> 2
combine 2
$init$ 0
map 2
whileM 3
whileM_ 2
untilM 3
untilM_ 2
iterateWhile 2
iterateUntil 2
iterateWhileM 3
iterateUntilM 3
$init$ 0
ensure 3
ensureOr 3
adaptError 2
rethrow 1
<init> 0
apply 1
$init$ 0
empty 0
algebra 0
compose 0
$init$ 0
nonEmptyTraverse 3
nonEmptySequence 2
nonEmptyFlatTraverse 4
nonEmptyFlatSequence 3
traverse 3
compose 1
<init> 0
<init> 0
ambiguousException 0
If$u0020you$u0020are$u0020seeing$u0020this$u002C$u0020you$u0020probably$u0020need$u0020to$u0020add$u0020an$u0020explicit$u0020type$u0020parameter$u0020somewhere$u002C$u0020because$u0020Null$u0020is$u0020being$u0020inferred$u002E 0
catsAmbiguousNotNullNull2 0
catsNotNullForA 0
$init$ 0
apply 0
flatMap 0
sequential 0
parallel 0
parProductR 2
parFollowedBy 2
parProductL 2
parForEffect 2
$init$ 0
applicative 0
monad 0
apply 0
flatMap 0
applicativeError 1
<init> 0
apply 1
<init> 0
apply 1
parSequence 3
parTraverse 4
parFlatTraverse 5
parFlatSequence 4
parSequence_ 3
parTraverse_ 4
parNonEmptySequence 3
parNonEmptyTraverse 4
parNonEmptyFlatTraverse 5
parNonEmptyFlatSequence 4
parNonEmptySequence_ 3
parNonEmptyTraverse_ 4
parAp 3
parProduct 3
parAp2 4
applicativeError 2
identity 1
$init$ 0
reduceLeft 2
reduceRight 2
reduce 2
reduceK 2
reduceMap 3
reduceLeftTo 3
reduceLeftM 4
reduceMapM 4
reduceLeftToOption 3
reduceRightTo 3
reduceRightToOption 3
nonEmptyTraverse_ 3
nonEmptySequence_ 2
toNonEmptyList 1
compose 1
minimum 2
maximum 2
nonEmptyIntercalate 3
nonEmptyPartition 2
isEmpty 1
nonEmpty 1
minimumOption 2
maximumOption 2
<init> 1
split 1
foldLeft 3
foldRight 3
reduceLeftTo 3
reduceRightTo 3
size 1
get 2
fold 2
foldM 4
find 2
exists 2
forall 2
toList 1
toNonEmptyList 1
filter_ 2
takeWhile_ 2
dropWhile_ 2
$init$ 0
combineK 2
algebra 0
compose 0
product 2
<init> 0
<init> 0
apply 1
show 1
$init$ 0
typeClassInstance 0
self 0
show 0
$init$ 0
toShow 2
show 1
fromToString 0
<init> 1
<init> 0
mat 2
<init> 1
show 1
<init> 0
contramap 2
$init$ 0
tailRecM 2
$init$ 0
traverse 3
flatTraverse 4
sequence 2
flatSequence 3
compose 1
map 2
mapWithIndex 2
traverseWithIndexM 3
zipWithIndex 1
unorderedTraverse 3
unorderedSequence 2
$init$ 0
unorderedFoldMap 3
unorderedFold 2
isEmpty 1
nonEmpty 1
exists 2
forall 2
size 1
<init> 0
<init> 0
combine 2
<init> 0
combine 2
commutativeMonoidEval 1
$init$ 0
unorderedTraverse 3
unorderedSequence 2
$init$ 0
lift 1
id 0
dimap 3
second 1
split 2
merge 2
$init$ 0
choose 2
left 1
right 1
choice 2
$init$ 0
id 0
algebraK 0
algebra 0
$init$ 0
choice 2
codiagonal 0
$init$ 0
compose 2
andThen 2
algebraK 0
algebra 0
$init$ 0
apply 1
compose 1
andThen 1
or 1
and 1
<init> 0
id 0
lift 1
<init> 0
lift 4
<init> 1
lift 3
unblock 1
punchHole 1
$init$ 0
dimap 3
lmap 2
rmap 2
first 1
second 1
<init> 1
dimap 3
lmap 2
map 1
contramapValue 1
flatMap 1
compose 2
andThen 2
first 1
second 1
<init> 0
pure 1
<init> 0
<init> 0
F 0
catsDataMonadForCokleisli 0
catsDataMonoidKForCokleisli 1
<init> 0
catsDataArrowForCokleisli 1
<init> 0
catsDataComposeForCokleisli 1
catsDataProfunctorForCokleisli 1
catsDataSemigroupKForCokleisli 1
catsDataContravariantForCokleisli 1
<init> 0
pure 1
flatMap 2
map 2
tailRecM 2
$init$ 0
F 0
lift 1
first 1
second 1
dimap 3
split 2
$init$ 0
F 0
compose 2
$init$ 0
F 0
dimap 3
lmap 2
rmap 2
<init> 1
retag 0
combine 2
traverse 2
$eq$eq$eq 2
partialCompare 2
compare 2
show 1
<init> 0
empty 1
<init> 1
apply 1
of 0
<init> 0
catsDataOrderForConst 1
catsDataShowForConst 1
catsDataContravariantMonoidalForConst 1
catsDataTraverseForConst 0
catsDataMonoidForConst 1
<init> 0
bifoldLeft 4
bifoldRight 4
<init> 0
catsDataSemigroupForConst 1
catsDataContravariantForConst 0
catsDataPartialOrderForConst 1
catsDataApplicativeForConst 1
<init> 0
catsDataEqForConst 1
catsDataApplyForConst 1
<init> 1
map 3
mapK 1
coflatMap 3
coflatten 2
extract 2
contramap 3
foldRight 4
foldLeft 4
foldMap 4
traverse 4
isLeft 0
isRight 0
swap 0
toValidated 0
fold 2
<init> 0
leftc 1
rightc 1
<init> 0
apply 1
<init> 0
apply 1
left 0
right 0
<init> 0
catsDataEqForEitherK 1
catsDataFunctorForEitherK 2
catsDataFoldableForEitherK 2
<init> 0
catsDataContravariantForEitherK 2
<init> 0
catsDataCoflatMapForEitherK 2
<init> 0
catsDataTraverseForEitherK 2
<init> 0
catsDataComonadForEitherK 2
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
foldRight 3
foldLeft 3
size 1
get 2
foldMap 3
$init$ 0
F 0
G 0
map 2
traverse 3
$init$ 0
F 0
G 0
map 2
coflatMap 2
coflatten 1
$init$ 0
F 0
G 0
extract 1
<init> 1
fold 3
isLeft 1
isRight 1
swap 1
getOrElse 2
getOrElseF 2
orElse 2
recover 2
recoverWith 2
valueOr 2
forall 2
exists 2
ensure 3
ensureOr 3
toOption 1
to 2
collectRight 2
bimap 3
bitraverse 4
applyAlt 2
flatMap 2
flatMapF 2
transform 2
subflatMap 2
map 2
mapK 1
semiflatMap 2
leftMap 2
leftFlatMap 2
leftSemiflatMap 2
compare 2
partialCompare 2
$eq$eq$eq 2
traverse 3
foldLeft 3
foldRight 3
merge 2
combine 3
toValidated 1
toValidatedNel 1
withValidated 2
show 1
toNested 0
toNestedValidated 1
toNestedValidatedNel 1
<init> 0
<init> 1
apply 2
left 0
<init> 1
apply 2
leftT 0
<init> 1
apply 2
right 0
<init> 1
apply 2
pure 0
rightT 0
liftF 2
liftK 1
liftT 2
fromEither 0
<init> 1
apply 2
fromOption 0
<init> 1
apply 3
fromOptionF 3
cond 0
<init> 1
apply 4
<init> 0
catsDataOrderForEitherT 1
catsDataShowForEitherT 1
catsDataBifunctorForEitherT 1
catsDataTraverseForEitherT 1
catsMonoidForEitherT 1
<init> 0
catsSemigroupForEitherT 1
catsDataFoldableForEitherT 1
catsDataPartialOrderForEitherT 1
catsDataBitraverseForEitherT 1
catsDataMonadErrorForEitherT 1
<init> 0
catsDataMonadErrorFForEitherT 1
catsDataSemigroupKForEitherT 1
catsDataEqForEitherT 1
<init> 0
catsDataFunctorForEitherT 1
$init$ 0
combine 2
$init$ 0
empty 0
$init$ 0
combineK 2
$init$ 0
map 2
$init$ 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
handleErrorWith 2
raiseError 1
$init$ 0
handleErrorWith 2
handleError 2
raiseError 1
attempt 1
recover 2
recoverWith 2
$init$ 0
F0 0
foldLeft 3
foldRight 3
$init$ 0
F0 0
traverse 3
$init$ 0
F0 0
bifoldLeft 4
bifoldRight 4
$init$ 0
F0 0
bitraverse 4
$init$ 0
F0 0
eqv 2
$init$ 0
F0 0
partialCompare 2
$init$ 0
F0 0
compare 2
<init> 0
run 0
map 2
mapK 1
<init> 0
func 1
appFunc 2
<init> 0
catsDataApplicativeForFunc 1
<init> 0
catsDataApplyForFunc 1
<init> 0
catsDataFunctorForFunc 1
catsDataContravariantForFunc 1
$init$ 0
F 0
map 2
$init$ 0
F 0
contramap 2
$init$ 0
F 0
ap 2
product 2
$init$ 0
F 0
pure 1
<init> 0
F 0
product 1
compose 1
andThen 1
map 1
traverse 2
<init> 0
<init> 0
appFuncApplicative 1
$init$ 0
F 0
map 2
ap 2
product 2
pure 1
<init> 1
map 2
mapK 1
flatMap 2
flatMapF 2
foldLeft 3
foldRight 3
reduceLeftTo 3
reduceRightTo 3
traverse 3
nonEmptyTraverse 3
ap 2
<init> 0
pure 2
$init$ 0
map 2
$init$ 0
ap 2
map2Eval 3
$init$ 0
pure 1
$init$ 0
unit 0
contramap 2
product 2
$init$ 0
flatMap 2
tailRecM 2
$init$ 0
foldLeft 3
foldRight 3
size 1
get 2
$init$ 0
traverse 3
$init$ 0
nonEmptyTraverse 3
reduceLeftTo 3
reduceRightTo 3
<init> 0
catsDataCommutativeFlatMapForIdT 1
<init> 0
catsDataCommutativeMonadForIdT 1
<init> 0
catsDataContravariantMonoidalForIdT 1
<init> 0
catsDataFunctorForIdT 1
<init> 0
catsDataApplyForIdT 1
<init> 0
catsDataApplicativeForIdT 1
<init> 0
catsDataFlatMapForIdT 1
<init> 0
catsDataMonadForIdT 1
catsDataFoldableForIdT 1
<init> 0
catsDataTraverseForIdT 1
catsDataEqForIdT 1
<init> 0
catsDataNonEmptyTraverseForIdT 1
catsDataOrderForIdT 1
catsDataShowForIdT 1
<init> 1
contramap 2
local 2
map 2
mapK 2
bimap 3
dimap 3
mapWritten 2
flatMap 3
flatMapF 2
transform 2
transformF 3
transformS 3
modify 2
inspect 2
get 1
tell 3
written 1
reset 2
run 3
runEmpty 3
runA 3
runS 3
runL 3
runEmptyA 3
runEmptyS 3
runEmptyL 3
$init$ 0
pure 3
liftF 3
liftK 2
lift 3
inspect 3
inspectF 3
set 3
setF 3
ask 2
tell 2
tellF 2
get 2
<init> 0
apply 2
applyF 1
modify 3
modifyF 3
<init> 0
apply 2
applyF 1
modify 3
modifyF 3
<init> 0
apply 2
pure 2
modify 2
inspect 2
get 1
set 2
ask 1
tell 1
<init> 0
catsDataProfunctorForIRWST 1
catsDataBifunctorForIRWST 1
catsDataContravariantForIRWST 1
catsDataMonadErrorForIRWST 2
<init> 0
catsDataMonadForRWST 2
catsDataStrongForIRWST 1
<init> 0
catsDataAlternativeForIRWST 3
<init> 0
catsDataSemigroupKForIRWST 2
catsDataFunctorForIRWST 1
<init> 0
F 0
map 2
<init> 0
F 0
contramap 2
<init> 0
F 0
dimap 3
<init> 0
F 0
first 1
second 1
<init> 0
F 0
bimap 3
<init> 0
F 0
L 0
pure 1
flatMap 2
tailRecM 2
<init> 0
F 0
G 0
combineK 2
<init> 0
F 0
G 0
L 0
combineK 2
empty 0
pure 1
ap 2
<init> 0
F 0
raiseError 1
handleErrorWith 2
<init> 1
flatMap 2
flatMapF 2
map 2
mapK 2
contramap 2
bimap 3
dimap 3
run 2
runS 2
runA 2
runEmpty 2
runEmptyS 2
runEmptyA 2
transform 2
transformF 3
transformS 3
modify 2
inspect 2
get 1
$init$ 0
pure 2
liftF 2
liftK 1
lift 2
inspect 2
inspectF 2
get 1
<init> 0
apply 2
applyF 1
modify 2
modifyF 2
set 2
setF 2
<init> 0
apply 2
applyF 1
modify 2
modifyF 2
set 2
setF 2
<init> 0
catsDataAlternativeForIndexedStateT 2
<init> 0
catsDataMonadErrorForIndexedStateT 1
catsDataSemigroupKForIndexedStateT 2
<init> 0
catsDataMonadForIndexedStateT 1
<init> 0
catsDataFunctorForIndexedStateT 1
catsDataContravariantForIndexedStateT 1
catsDataProfunctorForIndexedStateT 1
catsDataBifunctorForIndexedStateT 1
<init> 0
catsDataStrongForIndexedStateT 1
<init> 0
apply 1
pure 1
modify 1
inspect 1
get 0
set 1
<init> 0
F 0
map 2
<init> 0
F 0
contramap 2
<init> 0
F 0
bimap 3
<init> 0
F 0
dimap 3
<init> 0
F 0
first 1
second 1
<init> 0
F 0
pure 1
flatMap 2
tailRecM 2
<init> 0
F 0
G 0
combineK 2
<init> 0
F 0
G 0
unit 0
contramap 2
product 2
contramap2 3
<init> 0
G 0
combineK 2
empty 0
<init> 0
F 0
raiseError 1
handleErrorWith 2
<init> 0
fold 3
putLeft 1
putRight 1
isLeft 0
isRight 0
isBoth 0
left 0
right 0
onlyLeft 0
onlyRight 0
onlyLeftOrRight 0
onlyBoth 0
pad 0
unwrap 0
toEither 0
toValidated 0
toOption 0
toList 0
to 1
swap 0
exists 1
forall 1
getOrElse 1
valueOr 2
bimap 2
map 1
leftMap 1
flatMap 2
foreach 1
traverse 2
foldLeft 2
foldRight 2
merge 2
mergeLeft 1
mergeRight 1
combine 3
$eq$eq$eq 3
show 2
<init> 0
<init> 1
<init> 1
<init> 2
<init> 0
catsDataEqForIor 2
catsDataShowForIor 2
catsDataSemigroupForIor 2
catsDataMonadErrorForIor 1
catsDataBifunctorForIor 0
catsDataParallelForIor 1
<init> 0
catsDataTraverseFunctorForIor 0
$init$ 0
left 1
right 1
both 2
leftNel 1
bothNel 2
fromOptions 2
fromEither 1
<init> 1
fold 4
isLeft 1
isRight 1
isBoth 1
swap 1
getOrElse 2
getOrElseF 2
valueOr 3
forall 2
exists 2
toOption 1
toEither 1
toNested 0
toNestedValidated 1
toValidated 1
to 2
collectRight 2
merge 3
show 1
map 2
mapK 1
bimap 3
leftMap 2
leftFlatMap 3
leftSemiflatMap 2
transform 2
applyAlt 3
flatMap 3
flatMapF 3
subflatMap 3
semiflatMap 2
traverse 3
foldLeft 3
foldRight 3
$eq$eq$eq 2
combine 4
<init> 0
<init> 1
apply 2
left 0
<init> 1
apply 2
leftT 0
<init> 1
apply 2
right 0
rightT 0
both 3
<init> 1
apply 3
bothT 0
<init> 1
apply 2
pure 0
liftF 2
liftK 1
<init> 1
apply 2
fromIor 0
<init> 1
apply 2
fromEither 0
fromEitherF 2
<init> 1
apply 3
fromOption 0
fromOptionF 3
<init> 1
apply 4
cond 0
condF 4
<init> 0
catsDataShowForIorT 1
catsDataBifunctorForIorT 1
catsDataTraverseForIorT 1
catsDataMonoidForIorT 1
catsDataParallelForIorTWithParallelEffect 2
<init> 0
catsDataSemigroupForIorT 1
catsDataFoldableForIorT 1
catsDataMonadErrorForIorT 2
catsDataParallelForIorTWithSequentialEffect 2
<init> 0
catsDataMonadErrorFForIorT 2
catsDataEqForIorT 1
<init> 0
catsDataFunctorForIorT 1
$init$ 0
F0 0
map 2
$init$ 0
F0 0
eqv 2
$init$ 0
A0 0
F0 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
raiseError 1
handleErrorWith 2
$init$ 0
F0 0
raiseError 1
handleErrorWith 2
$init$ 0
F0 0
combine 2
$init$ 0
F0 0
empty 0
$init$ 0
F0 0
foldLeft 3
foldRight 3
$init$ 0
F0 0
traverse 3
<init> 1
ap 2
dimap 3
map 2
mapF 1
mapK 1
flatMap 2
flatMapF 2
andThen 2
andThen 2
compose 2
compose 2
traverse 3
lift 1
local 1
transform 1
lower 1
first 1
second 1
tap 1
tapWith 2
toReader 0
apply 1
<init> 0
$init$ 0
liftF 1
liftK 0
lift 1
pure 2
ask 1
local 2
$init$ 0
endoSemigroupK 1
endoMonoidK 1
<init> 0
catsDataCommutativeMonadForKleisli 1
catsDataArrowChoiceForKleisli 1
<init> 0
catsDataMonoidForKleisli 1
catsDataMonadErrorForKleisli 1
catsDataMonadForKleisliId 0
catsDataContravariantMonoidalForKleisli 1
<init> 0
catsDataMonadForKleisli 1
catsDataCommutativeArrowForKleisli 1
catsDataParallelForKleisli 1
catsDataContravariantForKleisli 0
<init> 0
catsDataAlternativeForKleisli 1
<init> 0
catsDataMonoidKForKleisli 1
catsDataFlatMapForKleisli 1
catsDataChoiceForKleisli 1
catsDataComposeForKleisli 1
catsDataStrongForKleisli 1
catsDataSemigroupForKleisli 1
<init> 0
catsDataSemigroupKForKleisli 1
catsDataApplicativeErrorForKleisli 1
catsDataCommutativeFlatMapForKleisli 1
<init> 0
catsDataApplicativeForKleisli 1
<init> 0
catsDataApplyForKleisli 1
<init> 0
catsDataDistributiveForKleisli 1
<init> 0
catsDataFunctorForKleisli 1
F 0
$init$ 0
F 0
lift 1
split 2
choose 2
$init$ 0
F 0
lmap 2
rmap 2
dimap 3
first 1
second 1
$init$ 0
choice 2
$init$ 0
F 0
id 0
$init$ 0
F 0
compose 2
$init$ 0
FB 0
combine 2
$init$ 0
FB 0
empty 0
$init$ 0
F 0
combineK 2
$init$ 0
F 0
empty 0
F 0
$init$ 0
F 0
unit 0
contramap 2
product 2
F 0
$init$ 0
F 0
raiseError 1
handleErrorWith 2
F 0
$init$ 0
F 0
flatMap 2
tailRecM 2
$init$ 0
F 0
pure 1
$init$ 0
F 0
ap 2
product 2
$init$ 0
F 0
map 2
$init$ 0
F 0
distribute 3
map 2
<init> 1
mapK 1
<init> 0
<init> 0
catsDataEqForNested 1
catsDataNonEmptyTraverseForNested 2
catsDataContravariantMonoidalForApplicativeForNested 2
<init> 0
catsDataTraverseForNested 2
<init> 0
catsDataReducibleForNested 2
catsDataFunctorForContravariantForNested 2
<init> 0
catsDataFoldableForNested 2
catsDataContravariantForCovariantNested 2
<init> 0
catsDataAlternativeForNested 2
catsDataContravariantForContravariantNested 2
<init> 0
catsDataApplicativeErrorForNested 2
<init> 0
catsDataCommutativeApplicativeForNestedContravariant 2
catsDataMonoidKForNested 1
<init> 0
catsDataCommutativeApplyForNestedContravariant 2
catsDataSemigroupKForNested 1
<init> 0
catsDataApplicativeForNested 2
<init> 0
catsDataApplyForNested 2
catsDataDistributiveForNested 2
<init> 0
catsDataInvariantSemigroupalApplyForNested 2
<init> 0
catsDataFunctorForNested 2
<init> 0
catsDataInvariantForNested 2
<init> 0
catsDataInvariantForCovariantNested 2
<init> 0
catsDataInvariantForNestedContravariant 2
$init$ 0
FG 0
imap 3
$init$ 0
FG 0
map 2
$init$ 0
FG 0
ap 2
product 2
$init$ 0
FG 0
pure 1
<init> 0
G 0
AEF 0
FG 0
raiseError 1
handleErrorWith 2
$init$ 0
FG 0
combineK 2
$init$ 0
FG 0
empty 0
FG 0
$init$ 0
FG 0
foldLeft 3
foldRight 3
$init$ 0
FG 0
traverse 3
$init$ 0
FG 0
distribute 3
$init$ 0
FG 0
reduceLeftTo 3
reduceRightTo 3
$init$ 0
FG 0
nonEmptyTraverse 3
$init$ 0
FG 0
contramap 2
$init$ 0
FG 0
unit 0
contramap 2
product 2
$init$ 0
FG 0
imap 3
product 2
<init> 2
toList 0
last 0
init 0
size 0
length 0
map 1
$plus$plus 1
concat 1
concat 1
concatNel 1
flatMap 1
$colon$colon 1
prepend 1
$colon$colon$colon 1
filter 1
filterNot 1
collect 1
find 1
exists 1
forall 1
foldLeft 2
foldRight 2
reduceLeft 1
reduce 1
traverse 2
coflatMap 1
$eq$eq$eq 2
show 1
toString 0
distinct 1
reverse 0
zipWith 2
zipWithIndex 0
sortBy 2
sorted 1
groupBy 2
<init> 0
of 2
ofInitLast 2
one 1
fromList 1
fromListUnsafe 1
fromFoldable 2
fromReducible 2
<init> 1
<init> 0
apply 1
<init> 0
ap 2
map 2
product 2
zipNelEq 1
<init> 0
<init> 0
combineK 2
split 1
reduceLeft 2
reduce 2
map 2
pure 1
flatMap 2
coflatMap 2
extract 1
nonEmptyTraverse 3
traverse 3
foldLeft 3
foldRight 3
foldMap 3
tailRecM 2
fold 2
nonEmptyPartition 2
find 2
forall 2
exists 2
toList 1
toNonEmptyList 1
get 2
catsDataShowForNonEmptyList 1
catsDataSemigroupForNonEmptyList 0
catsDataOrderForNonEmptyList 1
catsDataNonEmptyParallelForNonEmptyList 0
<init> 0
catsDataPartialOrderForNonEmptyList 1
<init> 0
catsDataEqForNonEmptyList 1
$init$ 0
A0 0
eqv 2
$init$ 0
A0 0
partialCompare 2
<init> 0
A0 0
compare 2
<init> 1
get 1
getUnsafe 1
updated 2
updatedUnsafe 2
head 0
tail 0
last 0
init 0
filter 1
filterNot 1
collect 1
$plus$plus 1
$plus$plus$colon 1
concat 1
concatNev 1
append 1
$colon$plus 1
prepend 1
$plus$colon 1
find 1
exists 1
forall 1
foldLeft 2
foldRight 2
map 1
flatMap 1
reduceLeft 1
reduce 1
$eq$eq$eq 2
show 1
length 0
toString 0
distinct 1
zipWith 2
reverse 0
zipWithIndex 0
sortBy 2
sorted 1
<init> 0
<init> 0
combineK 2
split 1
size 1
reduceLeft 2
reduce 2
map 2
pure 1
flatMap 2
coflatMap 2
extract 1
nonEmptyTraverse 3
traverse 3
zipWithIndex 1
foldLeft 3
foldRight 3
foldMap 3
nonEmptyPartition 2
get 2
tailRecM 2
fold 2
find 2
forall 2
exists 2
toList 1
toNonEmptyList 1
catsDataEqForNonEmptyVector 1
catsDataShowForNonEmptyVector 1
catsDataSemigroupForNonEmptyVector 0
catsDataParallelForNonEmptyVector 0
<init> 0
apply 2
of 2
one 1
unapply 1
fromVector 1
fromVectorUnsafe 1
<init> 1
<init> 0
apply 1
<init> 0
ap 2
map 2
product 2
zipNevEq 1
<init> 2
unwrap 1
filter 3
combine 2
find 2
exists 2
forall 2
reduceLeft 2
foldLeft 3
foldRight 3
map 2
mapK 1
$eq$eq$eq 3
show 2
<init> 0
catsDataParallelForOneAnd 3
catsDataEqForOneAnd 2
catsDataShowForOneAnd 2
catsDataSemigroupKForOneAnd 1
catsDataSemigroupForOneAnd 1
catsDataReducibleForOneAnd 1
catsDataMonadForOneAnd 2
<init> 0
<init> 0
coflatMap 2
extract 1
map 2
<init> 0
catsDataFunctorForOneAnd 1
<init> 0
catsDataApplicativeForOneAnd 1
<init> 0
catsDataTraverseForOneAnd 1
<init> 0
catsDataNonEmptyTraverseForOneAnd 2
<init> 0
<init> 1
fold 3
cata 3
map 2
mapK 1
semiflatMap 2
mapFilter 2
flatMap 2
flatMapF 2
transform 2
subflatMap 2
getOrElse 2
getOrElseF 2
collect 2
exists 2
filter 2
withFilter 2
filterNot 2
forall 2
isDefined 1
isEmpty 1
orElse 2
orElseF 2
toRight 2
toLeft 2
show 1
compare 2
partialCompare 2
$eq$eq$eq 2
traverse 3
foldLeft 3
foldRight 3
toNested 0
<init> 0
<init> 1
apply 2
pure 0
some 0
none 1
fromOption 0
<init> 1
apply 2
liftF 2
liftK 1
<init> 0
catsDataMonadForOptionT 1
catsDataFoldableForOptionT 1
catsDataSemigroupForOptionT 1
catsDataOrderForOptionT 1
catsDataShowForOptionT 1
<init> 0
catsDataMonadErrorForOptionT 1
catsDataContravariantMonoidalForOptionT 1
catsDataSemigroupKForOptionT 1
catsDataMonoidForOptionT 1
catsDataPartialOrderForOptionT 1
<init> 0
catsDataMonoidKForOptionT 1
catsDataEqForOptionT 1
<init> 0
catsDataTraverseForOptionT 1
<init> 0
catsDataFunctorForOptionT 1
$init$ 0
F 0
map 2
$init$ 0
F 0
pure 1
flatMap 2
map 2
tailRecM 2
$init$ 0
F 0
raiseError 1
handleErrorWith 2
$init$ 0
F 0
unit 0
contramap 2
product 2
$init$ 0
F 0
foldLeft 3
foldRight 3
$init$ 0
F 0
traverse 3
$init$ 0
combine 2
$init$ 0
empty 0
$init$ 0
F 0
combineK 2
$init$ 0
empty 0
$init$ 0
F 0
eqv 2
$init$ 0
F 0
partialCompare 2
$init$ 0
F 0
compare 2
<init> 2
mapK 1
<init> 0
<init> 0
catsDataOrderForTuple2K 2
catsDataShowForTuple2K 2
catsDataContravariantMonoidalForTuple2k 2
<init> 0
catsDataTraverseForTuple2K 2
catsDataContravariantForTuple2K 2
catsDataEqForTuple2K 2
<init> 0
catsDataAlternativeForTuple2K 2
catsDataFoldableForTuple2K 2
<init> 0
catsDataMonadForTuple2K 2
catsDataMonoidKForTuple2K 2
<init> 0
catsDataCommutativeApplicativeForTuple2K 2
<init> 0
catsDataSemigroupKForTuple2K 2
catsDataCommutativeApplyForTuple2K 2
<init> 0
catsDataApplicativeForTuple2K 2
<init> 0
catsDataApplyForTuple2K 2
<init> 0
catsDataDistributiveForTuple2K 2
<init> 0
catsDataFunctorForTuple2K 2
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
distribute 3
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
unit 0
product 2
contramap 2
$init$ 0
F 0
G 0
ap 2
product 2
map2Eval 3
$init$ 0
F 0
G 0
pure 1
$init$ 0
F 0
G 0
combineK 2
$init$ 0
F 0
G 0
empty 0
F 0
G 0
$init$ 0
F 0
G 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
F 0
G 0
foldLeft 3
foldRight 3
$init$ 0
F 0
G 0
traverse 3
$init$ 0
F 0
G 0
show 1
$init$ 0
F 0
G 0
compare 2
<init> 0
fold 2
isValid 0
isInvalid 0
foreach 1
getOrElse 1
valueOr 1
exists 1
forall 1
orElse 1
findValid 2
toEither 0
toOption 0
toIor 0
toList 0
toValidatedNel 0
withEither 1
bimap 2
compare 3
partialCompare 3
$eq$eq$eq 3
ap 2
product 2
map 1
leftMap 1
traverse 2
foldLeft 2
foldRight 2
show 2
andThen 1
combine 3
swap 0
merge 1
ensure 2
ensureOr 2
<init> 0
<init> 1
<init> 1
catchOnly 0
<init> 1
apply 3
<init> 0
catsDataSemigroupKForValidated 1
catsDataMonoidForValidated 2
catsDataOrderForValidated 2
catsDataShowForValidated 2
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
bimap 3
leftMap 2
catsDataApplicativeErrorForValidated 1
<init> 0
catsDataSemigroupForValidated 2
catsDataCommutativeApplicativeForValidated 1
catsDataPartialOrderForValidated 2
<init> 0
catsDataEqForValidated 2
catsDataTraverseFunctorForValidated 0
<init> 1
map 2
pure 1
ap 2
product 2
$init$ 0
invalid 1
invalidNel 1
valid 1
validNel 1
catchNonFatal 1
fromTry 1
fromEither 1
fromOption 2
fromIor 1
cond 3
condNel 3
<init> 1
tell 3
written 1
value 1
ap 3
map 2
mapK 1
contramap 2
flatMap 3
mapBoth 2
bimap 3
mapWritten 2
swap 1
reset 2
show 1
<init> 0
liftF 3
liftK 2
lift 3
<init> 0
catsDataCommutativeMonadForWriterT 2
<init> 0
catsDataMonadErrorForWriterT 2
catsDataParallelForWriterT 2
catsDataEqForWriterTId 2
catsDataBifunctorForWriterT 1
catsDataShowForWriterT 1
catsDataMonoidForWriterTId 2
<init> 0
catsDataMonadForWriterTId 1
catsDataEqForWriterT 1
catsDataSemigroupForWriterTId 2
<init> 0
catsDataMonadForWriterT 2
catsDataMonoidForWriterT 1
catsDataCoflatMapForWriterTId 0
<init> 0
catsDataFlatMapForWriterTId 1
<init> 0
catsDataFlatMapForWriterT1 2
catsDataSemigroupForWriterT 1
<init> 0
catsDataApplicativeErrorForWriterT 2
<init> 0
catsDataAlternativeForWriterT 2
catsDataContravariantMonoidalForWriterT 1
<init> 0
catsDataMonoidKForWriterT 1
catsDataFlatMapForWriterT2 2
catsDataContravariantForWriterT 1
<init> 0
catsDataSemigroupKForWriterT 1
catsDataApplicativeForWriterT 2
<init> 0
catsDataApplyForWriterT 2
<init> 0
catsDataCoflatMapForWriterT 1
$init$ 0
F0 0
map 2
$init$ 0
F0 0
contramap 2
$init$ 0
F0 0
L0 0
ap 2
map2Eval 3
product 2
$init$ 0
F0 0
L0 0
flatMap 2
tailRecM 2
$init$ 0
F0 0
L0 0
flatMap 2
tailRecM 2
$init$ 0
F0 0
L0 0
pure 1
F0 0
L0 0
$init$ 0
F0 0
raiseError 1
handleErrorWith 2
F0 0
$init$ 0
F0 0
combineK 2
$init$ 0
F0 0
empty 0
F0 0
$init$ 0
F0 0
unit 0
contramap 2
product 2
$init$ 0
F0 0
combine 2
$init$ 0
F0 0
empty 0
$init$ 0
coflatMap 2
$init$ 0
putT 3
put 3
tell 2
value 3
valueT 3
<init> 1
<init> 0
apply 1
<init> 0
map 2
ap 2
product 2
catsDataEqForZipList 1
<init> 1
<init> 0
apply 1
<init> 0
pure 1
map 2
ap 2
product 2
empty 0
combineK 2
catsDataEqForZipStream 1
<init> 1
<init> 0
apply 1
<init> 0
map 2
ap 2
catsDataEqForZipVector 1
<init> 0
NonEmptyStream 2
NonEmptyStream 2
<init> 0
apply 1
<init> 0
apply 2
value 2
tell 1
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
substitute 1
andThen 1
compose 1
coerce 1
<init> 0
<init> 0
id 0
compose 2
<init> 0
<init> 0
substitute 1
refl 0
witness 1
compose 2
reify 0
fromPredef 1
co 1
co2 1
co2_2 1
co3 1
co3_2 1
co3_3 1
onF 2
lift2 2
contra 1
contra1_2 1
contra2_2 1
contra1_3 1
contra2_3 1
contra3_3 1
conF 2
invF 3
<init> 0
substitute 1
andThen 1
compose 1
flip 0
lift 0
coerce 1
predefEq 0
<init> 0
<init> 0
substitute 1
refl 0
unsafeFromPredef 1
<init> 0
<init> 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
catsStdShowForBitSet 0
$init$ 0
$init$ 0
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
catsStdInstancesForEither 0
catsStdSemigroupKForEither 0
catsStdShowForEither 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
extract 1
coflatMap 2
pure 1
flatMap 2
tailRecM 2
$init$ 0
function0Distributive 0
$init$ 0
catsStdContravariantMonoidalForFunction1 1
catsStdMonadForFunction1 0
<init> 0
choose 2
lift 1
first 1
split 2
compose 2
$init$ 0
catsStdContravariantForFunction1 0
catsStdDistributiveForFunction1 0
$init$ 0
catsStdInstancesForFuture 1
$init$ 0
catsStdMonoidForFuture 2
$init$ 0
catsStdSemigroupForFuture 2
<init> 1
map 2
coflatMap 2
<init> 2
<init> 2
$init$ 0
<init> 0
contramap 2
$init$ 0
catsSemigroupalForMonoid 0
<init> 0
product 2
imap 3
unit 0
<init> 0
product 2
imap 3
unit 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
tailRecM 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
partitionEither 3
get 2
exists 2
forall 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
filter_ 2
takeWhile_ 2
dropWhile_ 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForList 1
$init$ 0
catsStdShowForMap 2
catsStdInstancesForMap 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
tailRecM 2
map2 3
map2Eval 3
coflatMap 2
foldLeft 3
foldRight 3
raiseError 1
handleErrorWith 2
traverse 3
reduceLeftToOption 3
reduceRightToOption 3
reduceLeftOption 2
reduceRightOption 2
minimumOption 2
maximumOption 2
get 2
size 1
foldMap 3
find 2
exists 2
forall 2
toList 1
filter_ 2
takeWhile_ 2
dropWhile_ 2
isEmpty 1
collectFirst 2
collectFirstSome 2
catsStdShowForOption 1
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
$init$ 0
catsParallelForEitherValidated 1
catsParallelForOptionTNestedOption 1
catsStdNonEmptyParallelForZipList 0
catsStdNonEmptyParallelForZipVector 0
catsStdParallelForZipStream 0
catsParallelForEitherTNestedParallelValidated 2
$init$ 0
catsParallelForEitherTNestedValidated 2
$init$ 0
<init> 0
contramap 2
product 2
unit 0
$init$ 0
<init> 0
contramap 2
product 2
unit 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
tailRecM 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
get 2
exists 2
forall 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
filter_ 2
takeWhile_ 2
dropWhile_ 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForQueue 1
$init$ 0
<init> 0
unorderedTraverse 3
unorderedSequence 2
empty 0
combineK 2
unorderedFoldMap 3
unorderedFold 2
forall 2
isEmpty 1
catsStdShowForSet 1
$init$ 0
catsStdHashForSortedMap 3
catsStdCommutativeMonoidForSortedMap 2
catsStdShowForSortedMap 3
catsStdInstancesForSortedMap 1
$init$ 0
catsStdEqForSortedMap 2
$init$ 0
catsStdMonoidForSortedMap 2
<init> 3
hash 1
<init> 2
eqv 2
<init> 2
<init> 2
empty 0
combine 2
$init$ 0
<init> 0
combineK 2
foldLeft 3
foldRight 3
foldMap 3
get 2
size 1
exists 2
forall 2
isEmpty 1
fold 2
toList 1
reduceLeftOption 2
find 2
collectFirst 2
collectFirstSome 2
catsStdShowForSortedSet 1
catsKernelStdOrderForSortedSet 1
$init$ 0
catsKernelStdHashForSortedSet 2
catsKernelStdSemilatticeForSortedSet 1
<init> 1
compare 2
eqv 2
<init> 2
hash 1
eqv 2
<init> 1
empty 0
combine 2
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
tailRecM 2
exists 2
forall 2
get 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForStream 1
$init$ 0
<init> 0
$init$ 0
$init$ 0
catsStdInstancesForTry 0
catsStdShowForTry 1
catsStdEqForTry 2
<init> 0
castFailure 1
$init$ 0
catsStdMonoidForTry 1
$init$ 0
catsStdSemigroupForTry 1
<init> 0
map 2
coflatMap 2
<init> 1
<init> 1
$init$ 0
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
catsStdShowForTuple2 2
catsStdInstancesForTuple2 0
$init$ 0
catsStdCommutativeMonadForTuple2 1
$init$ 0
catsStdCommutativeFlatMapForTuple2 1
$init$ 0
catsStdMonadForTuple2 1
$init$ 0
catsStdFlatMapForTuple2 1
<init> 1
ap 2
product 2
map 2
flatMap 2
productR 2
productL 2
mproduct 2
tailRecM 2
$init$ 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
tailRecM 2
size 1
get 2
traverse 3
mapWithIndex 2
zipWithIndex 1
exists 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForVector 1
<init> 0
<init> 0
pure 1
extract 1
flatMap 2
coflatMap 2
tailRecM 2
distribute 3
map 2
ap 2
flatten 1
map2 3
lift 1
imap 3
foldLeft 3
foldRight 3
nonEmptyTraverse 3
foldMap 3
reduce 2
reduceLeftTo 3
reduceLeft 2
reduceLeftToOption 3
reduceRight 2
reduceRightTo 3
reduceRightToOption 3
reduceMap 3
size 1
get 2
isEmpty 1
$init$ 0
catsSyntaxDistributiveOps 2
<init> 1
distribute 3
cosequence 3
$init$ 0
catsSyntaxUnite 1
catsSyntaxAlternativeSeparate 1
catsSyntaxAlternativeGuard 1
<init> 1
unite 3
<init> 1
separate 3
<init> 1
guard 1
$init$ 0
catsSyntaxApplicativeId 1
catsSyntaxApplicative 1
<init> 1
pure 1
<init> 1
replicateA 2
unlessA 2
whenA 2
$init$ 0
catsSyntaxApplicativeErrorId 1
catsSyntaxApplicativeError 2
<init> 1
raiseError 1
<init> 1
handleError 2
handleErrorWith 2
attempt 1
attemptT 1
recover 2
recoverWith 2
onError 2
$init$ 0
catsSyntaxApply 2
catsSyntaxApplyOps 1
<init> 1
followedBy 2
forEffect 2
$init$ 0
catsSyntaxBitraverse 2
$init$ 0
catsSyntaxNestedBitraverse 2
<init> 1
bitraverse 4
<init> 1
bisequence 2
$init$ 0
catsSyntaxContravariantMonoidal 2
<init> 0
$init$ 0
catsSyntaxContravariantSemigroupal 2
$init$ 0
catsSyntaxEither 1
catsSyntaxEitherObject 1
catsSyntaxLeft 1
catsSyntaxRight 1
catsSyntaxEitherId 1
<init> 0
<init> 1
apply 3
<init> 1
foreach 1
getOrElse 1
orElse 1
recover 1
recoverWith 1
valueOr 1
forall 1
exists 1
ensure 2
ensureOr 2
toIor 0
toOption 0
toList 0
toTry 1
toValidated 0
toValidatedNel 0
withValidated 1
to 1
bimap 2
map 1
map2Eval 2
leftMap 1
flatMap 1
compare 3
partialCompare 3
$eq$eq$eq 3
traverse 2
foldLeft 2
foldRight 2
combine 2
show 2
ap 1
toEitherT 1
raiseOrPure 1
<init> 1
left 1
right 1
catchOnly 0
catchNonFatal 1
fromTry 1
fromOption 2
<init> 1
rightCast 0
<init> 1
leftCast 0
<init> 1
asLeft 0
asRight 0
<init> 0
leftCast 1
rightCast 1
$init$ 0
catsSyntaxEitherK 1
<init> 1
leftc 0
rightc 0
$init$ 0
catsSyntaxEq 2
<init> 2
$eq$eq$eq 1
$eq$bang$eq 1
$init$ 0
catsSyntaxFlatten 2
catsSyntaxIfM 2
catsSyntaxFlatMapIdOps 1
catsSyntaxFlatMapOps 2
<init> 1
$greater$greater$eq 2
$greater$greater 2
$less$less 2
followedByEval 2
forEffectEval 2
<init> 1
flatten 1
<init> 1
ifM 3
<init> 1
tailRecM 2
$init$ 0
catsSyntaxNestedFoldable 2
catsSyntaxFoldOps 2
<init> 1
sequence_ 2
foldK 2
<init> 1
foldl 3
foldr 3
$init$ 0
catsSyntaxGroup 2
<init> 2
$bar$minus$bar 1
remove 1
inverse 0
$init$ 0
catsSyntaxHash 2
<init> 2
hash 0
$init$ 0
catsSyntaxIorId 1
<init> 1
rightIor 0
leftIor 0
$init$ 0
catsSyntaxList 1
<init> 1
toNel 0
groupByNel 2
$init$ 0
catsSyntaxMonad 1
catsSyntaxMonadIdOps 1
<init> 1
whileM 3
whileM_ 2
untilM 3
untilM_ 2
iterateWhile 2
iterateUntil 2
<init> 1
iterateWhileM 3
iterateUntilM 3
$init$ 0
catsSyntaxMonadError 2
catsSyntaxMonadErrorRethrow 2
<init> 1
ensure 3
ensureOr 3
adaptError 2
<init> 1
rethrow 1
$init$ 0
catsSyntaxMonoid 2
<init> 1
isEmpty 2
$init$ 0
none 0
catsSyntaxOptionId 1
catsSyntaxOption 1
<init> 1
some 0
<init> 1
toInvalid 1
toInvalidNel 1
toValid 1
toValidNel 1
toRightIor 1
toLeftIor 1
orEmpty 1
$init$ 0
catsSyntaxOrder 2
<init> 2
compare 1
min 1
max 1
comparison 1
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
$init$ 0
catsSyntaxParallelTraverse 2
catsSyntaxParallelSequence 3
catsSyntaxParallelAp 2
<init> 1
parTraverse 4
<init> 1
parSequence 3
<init> 1
$amp$greater 2
$less$amp 2
$init$ 0
catsSyntaxPartialOrder 2
<init> 2
$greater 1
$greater$eq 1
$less 1
$less$eq 1
partialCompare 1
tryCompare 1
pmin 1
pmax 1
$init$ 0
catsSyntaxNestedReducible 2
<init> 1
reduceK 2
$init$ 0
catsSyntaxSemigroup 2
<init> 2
$bar$plus$bar 1
combine 1
combineN 1
$init$ 0
catsSyntaxSemigroupal 2
<init> 0
$bar$at$bar 1
$init$ 0
showInterpolator 1
$init$ 0
catsSyntaxValidatedId 1
<init> 1
valid 0
validNel 0
invalid 0
invalidNel 0
$init$ 0
catsSyntaxVectors 1
<init> 1
toNev 0
$init$ 0
catsSyntaxWriterId 1
<init> 1
tell 0
writer 1
$init$ 0
tuple2 2
ap3 4
map3 4
tuple3 3
ap4 5
map4 5
tuple4 4
ap5 6
map5 6
tuple5 5
ap6 7
map6 7
tuple6 6
ap7 8
map7 8
tuple7 7
ap8 9
map8 9
tuple8 8
ap9 10
map9 10
tuple9 9
ap10 11
map10 11
tuple10 10
ap11 12
map11 12
tuple11 11
ap12 13
map12 13
tuple12 12
ap13 14
map13 14
tuple13 13
ap14 15
map14 15
tuple14 14
ap15 16
map15 16
tuple15 15
ap16 17
map16 17
tuple16 16
ap17 18
map17 18
tuple17 17
ap18 19
map18 19
tuple18 18
ap19 20
map19 20
tuple19 19
ap20 21
map20 21
tuple20 20
ap21 22
map21 22
tuple21 21
ap22 23
map22 23
tuple22 22
$init$ 0
parMap2 4
parMap3 5
parMap4 6
parMap5 7
parMap6 8
parMap7 9
parMap8 10
parMap9 11
parMap10 12
parMap11 13
parMap12 14
parMap13 15
parMap14 16
parMap15 17
parMap16 18
parMap17 19
parMap18 20
parMap19 21
parMap20 22
parMap21 23
parMap22 24
$init$ 0
map2 5
contramap2 5
imap2 6
tuple2 4
traverse2 6
map3 6
contramap3 6
imap3 7
tuple3 5
traverse3 7
map4 7
contramap4 7
imap4 8
tuple4 6
traverse4 8
map5 8
contramap5 8
imap5 9
tuple5 7
traverse5 9
map6 9
contramap6 9
imap6 10
tuple6 8
traverse6 10
map7 10
contramap7 10
imap7 11
tuple7 9
traverse7 11
map8 11
contramap8 11
imap8 12
tuple8 10
traverse8 12
map9 12
contramap9 12
imap9 13
tuple9 11
traverse9 13
map10 13
contramap10 13
imap10 14
tuple10 12
traverse10 14
map11 14
contramap11 14
imap11 15
tuple11 13
traverse11 15
map12 15
contramap12 15
imap12 16
tuple12 14
traverse12 16
map13 16
contramap13 16
imap13 17
tuple13 15
traverse13 17
map14 17
contramap14 17
imap14 18
tuple14 16
traverse14 18
map15 18
contramap15 18
imap15 19
tuple15 17
traverse15 19
map16 19
contramap16 19
imap16 20
tuple16 18
traverse16 20
map17 20
contramap17 20
imap17 21
tuple17 19
traverse17 21
map18 21
contramap18 21
imap18 22
tuple18 20
traverse18 22
map19 22
contramap19 22
imap19 23
tuple19 21
traverse19 23
map20 23
contramap20 23
imap20 24
tuple20 22
traverse20 24
map21 24
contramap21 24
imap21 25
tuple21 23
traverse21 25
map22 25
contramap22 25
imap22 26
tuple22 24
traverse22 26
<init> 0
$bar$at$bar 1
<init> 1
$bar$at$bar 1
apWith 2
map 2
contramap 2
imap 3
<init> 2
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 3
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 4
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 5
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 6
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 7
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 8
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 9
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 10
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 11
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 12
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 13
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 14
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 15
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 16
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 17
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 18
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 19
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 20
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 21
$bar$at$bar 1
apWith 2
map 3
contramap 3
imap 4
tupled 2
<init> 22
apWith 2
map 3
contramap 3
imap 4
tupled 2
$init$ 0
catsSyntaxTuple1Parallel 1
catsSyntaxTuple2Parallel 1
catsSyntaxTuple3Parallel 1
catsSyntaxTuple4Parallel 1
catsSyntaxTuple5Parallel 1
catsSyntaxTuple6Parallel 1
catsSyntaxTuple7Parallel 1
catsSyntaxTuple8Parallel 1
catsSyntaxTuple9Parallel 1
catsSyntaxTuple10Parallel 1
catsSyntaxTuple11Parallel 1
catsSyntaxTuple12Parallel 1
catsSyntaxTuple13Parallel 1
catsSyntaxTuple14Parallel 1
catsSyntaxTuple15Parallel 1
catsSyntaxTuple16Parallel 1
catsSyntaxTuple17Parallel 1
catsSyntaxTuple18Parallel 1
catsSyntaxTuple19Parallel 1
catsSyntaxTuple20Parallel 1
catsSyntaxTuple21Parallel 1
catsSyntaxTuple22Parallel 1
<init> 1
parMap 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
<init> 1
parMapN 2
$init$ 0
catsSyntaxTuple1Semigroupal 1
catsSyntaxTuple2Semigroupal 1
catsSyntaxTuple3Semigroupal 1
catsSyntaxTuple4Semigroupal 1
catsSyntaxTuple5Semigroupal 1
catsSyntaxTuple6Semigroupal 1
catsSyntaxTuple7Semigroupal 1
catsSyntaxTuple8Semigroupal 1
catsSyntaxTuple9Semigroupal 1
catsSyntaxTuple10Semigroupal 1
catsSyntaxTuple11Semigroupal 1
catsSyntaxTuple12Semigroupal 1
catsSyntaxTuple13Semigroupal 1
catsSyntaxTuple14Semigroupal 1
catsSyntaxTuple15Semigroupal 1
catsSyntaxTuple16Semigroupal 1
catsSyntaxTuple17Semigroupal 1
catsSyntaxTuple18Semigroupal 1
catsSyntaxTuple19Semigroupal 1
catsSyntaxTuple20Semigroupal 1
catsSyntaxTuple21Semigroupal 1
catsSyntaxTuple22Semigroupal 1
<init> 1
map 2
contramap 2
imap 3
traverse 3
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
<init> 1
mapN 3
contramapN 3
imapN 4
tupled 2
traverseN 4
apWith 2
$init$ 0
unite 3
separate 3
guard 1
compose 1
$init$ 0
pure 1
unit 0
map 2
replicateA 2
compose 1
composeContravariantMonoidal 1
unlessA 2
whenA 2
<init> 0
monoid 2
catsApplicativeForArrow 1
coflatMap 1
<init> 2
empty 0
<init> 1
pure 1
map 2
ap 2
product 2
$init$ 0
raiseError 1
handleErrorWith 2
handleError 2
attempt 1
attemptT 1
recover 2
recoverWith 2
onError 2
catchNonFatal 2
catchNonFatalEval 2
fromTry 2
fromEither 1
<init> 0
apply 1
$init$ 0
ap 2
productR 2
productL 2
product 2
$less$times$greater 2
$times$greater 2
$less$times 2
followedBy 2
forEffect 2
ap2 3
map2 3
map2Eval 3
compose 1
<init> 0
semigroup 2
<init> 2
combine 2
$init$ 0
bifoldLeft 4
bifoldRight 4
bifoldMap 4
compose 1
$init$ 0
F 0
G 0
bifoldLeft 4
bifoldRight 4
$init$ 0
bimap 3
rightFunctor 0
leftFunctor 0
leftMap 2
compose 1
leftWiden 1
$init$ 0
F 0
G 0
bimap 3
<init> 0
map 2
<init> 0
map 2
$init$ 0
bitraverse 4
bisequence 2
compose 1
bimap 3
$init$ 0
F 0
G 0
bitraverse 4
$init$ 0
coflatMap 2
coflatten 1
extract 1
$init$ 0
F 0
G 0
distribute 3
$init$ 0
F 0
G 0
imap 3
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
ap 2
product 2
$init$ 0
F 0
G 0
pure 1
$init$ 0
F 0
combineK 2
$init$ 0
F 0
empty 0
F 0
$init$ 0
F 0
G 0
foldLeft 3
foldRight 3
$init$ 0
F 0
G 0
traverse 3
$init$ 0
F 0
G 0
nonEmptyTraverse 3
$init$ 0
F 0
G 0
reduceLeftTo 3
reduceRightTo 3
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
unit 0
contramap 2
product 2
$init$ 0
F 0
G 0
product 2
$init$ 0
F 0
G 0
product 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
imap 3
$init$ 0
F 0
G 0
imap 3
$init$ 0
contramap 2
imap 3
compose 1
narrow 1
liftContravariant 1
composeFunctor 1
$init$ 0
trivial 0
<init> 0
monoid 1
<init> 1
empty 0
$init$ 0
composeFunctor 1
<init> 0
semigroup 1
<init> 1
combine 2
$init$ 0
distribute 3
cosequence 2
compose 1
<init> 0
value 0
map 1
flatMap 1
memoize 0
<init> 1
memoize 0
<init> 1
memoize 0
<init> 0
apply 1
<init> 1
value 0
memoize 0
<init> 0
apply 1
<init> 0
now 1
later 1
always 1
defer 1
<init> 1
memoize 0
value 0
advance 1
advance1 1
<init> 0
memoize 0
value 0
<init> 1
memoize 0
value 0
evaluate 1
<init> 0
<init> 0
map 2
pure 1
flatMap 2
extract 1
coflatMap 2
<init> 0
foldLeft 3
foldRight 3
reduce 2
reduceLeft 2
reduceLeftTo 3
reduceRight 2
reduceRightTo 3
reduceRightOption 2
reduceRightToOption 3
size 1
catsOrderForEval 1
catsGroupForEval 1
<init> 0
catsPartialOrderForEval 1
catsMonoidForEval 1
<init> 0
catsEqForEval 1
catsSemigroupForEval 1
$init$ 0
algebra 0
combine 2
$init$ 0
algebra 0
$init$ 0
algebra 0
inverse 1
remove 2
$init$ 0
flatMap 2
flatten 1
productREval 2
followedByEval 2
productLEval 2
forEffectEval 2
ap 2
product 2
mproduct 2
ifM 3
tailRecM 2
flatTap 2
$init$ 0
foldLeft 3
foldRight 3
reduceLeftToOption 3
reduceRightToOption 3
reduceLeftOption 2
reduceRightOption 2
minimumOption 2
maximumOption 2
get 2
collectFirst 2
collectFirstSome 2
fold 2
combineAll 2
foldMap 3
foldM 4
foldLeftM 4
foldMapM 4
traverse_ 3
sequence_ 2
foldK 2
find 2
exists 2
forall 2
existsM 3
forallM 3
toList 1
partitionEither 3
filter_ 2
takeWhile_ 2
dropWhile_ 2
isEmpty 1
nonEmpty 1
intercalate 3
intersperseList 2
compose 1
unorderedFold 2
unorderedFoldMap 3
<init> 0
<init> 0
apply 1
iterateRight 3
<init> 0
uncons 0
<init> 0
<init> 0
uncons 0
cons 2
fromFoldable 2
$init$ 0
map 2
imap 3
fmap 2
widen 1
lift 1
void 1
fproduct 2
as 2
tupleLeft 2
tupleRight 2
compose 1
composeContravariant 1
<init> 0
inj 0
prj 0
apply 1
unapply 1
<init> 0
catsReflexiveInjectInstance 0
catsLeftInjectInstance 0
catsRightInjectInstance 1
<init> 0
apply 1
<init> 0
inj 0
prj 0
apply 1
unapply 1
<init> 0
catsReflexiveInjectKInstance 0
catsLeftInjectKInstance 0
catsRightInjectKInstance 1
<init> 0
apply 1
$init$ 0
imap 3
compose 1
composeFunctor 1
composeContravariant 1
<init> 0
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
<init> 0
imap 3
$init$ 0
point 1
unit 0
<init> 0
monoid 2
<init> 2
empty 0
$init$ 0
composeApply 1
<init> 0
semigroup 2
<init> 2
combine 2
$init$ 0
map 2
whileM 3
whileM_ 2
untilM 3
untilM_ 2
iterateWhile 2
iterateUntil 2
iterateWhileM 3
iterateUntilM 3
$init$ 0
ensure 3
ensureOr 3
adaptError 2
rethrow 1
<init> 0
apply 1
$init$ 0
empty 0
algebra 0
compose 0
$init$ 0
nonEmptyTraverse 3
nonEmptySequence 2
nonEmptyFlatTraverse 4
nonEmptyFlatSequence 3
traverse 3
compose 1
<init> 0
<init> 0
ambiguousException 0
If$u0020you$u0020are$u0020seeing$u0020this$u002C$u0020you$u0020probably$u0020need$u0020to$u0020add$u0020an$u0020explicit$u0020type$u0020parameter$u0020somewhere$u002C$u0020because$u0020Null$u0020is$u0020being$u0020inferred$u002E 0
catsAmbiguousNotNullNull2 0
catsNotNullForA 0
$init$ 0
apply 0
flatMap 0
sequential 0
parallel 0
parProductR 2
parFollowedBy 2
parProductL 2
parForEffect 2
$init$ 0
applicative 0
monad 0
apply 0
flatMap 0
applicativeError 1
<init> 0
apply 1
<init> 0
apply 1
parSequence 3
parTraverse 4
parFlatTraverse 5
parFlatSequence 4
parSequence_ 3
parTraverse_ 4
parNonEmptySequence 3
parNonEmptyTraverse 4
parNonEmptyFlatTraverse 5
parNonEmptyFlatSequence 4
parNonEmptySequence_ 3
parNonEmptyTraverse_ 4
parAp 3
parProduct 3
parAp2 4
applicativeError 2
identity 1
$init$ 0
reduceLeft 2
reduceRight 2
reduce 2
reduceK 2
reduceMap 3
reduceLeftTo 3
reduceLeftM 4
reduceMapM 4
reduceLeftToOption 3
reduceRightTo 3
reduceRightToOption 3
nonEmptyTraverse_ 3
nonEmptySequence_ 2
toNonEmptyList 1
compose 1
minimum 2
maximum 2
nonEmptyIntercalate 3
nonEmptyPartition 2
isEmpty 1
nonEmpty 1
minimumOption 2
maximumOption 2
<init> 1
split 1
foldLeft 3
foldRight 3
reduceLeftTo 3
reduceRightTo 3
size 1
get 2
fold 2
foldM 4
find 2
exists 2
forall 2
toList 1
toNonEmptyList 1
filter_ 2
takeWhile_ 2
dropWhile_ 2
$init$ 0
combineK 2
algebra 0
compose 0
product 2
<init> 0
<init> 0
apply 1
show 1
$init$ 0
typeClassInstance 0
self 0
show 0
$init$ 0
toShow 2
show 1
fromToString 0
<init> 1
<init> 0
mat 2
<init> 1
show 1
<init> 0
contramap 2
$init$ 0
tailRecM 2
$init$ 0
traverse 3
flatTraverse 4
sequence 2
flatSequence 3
compose 1
map 2
mapWithIndex 2
traverseWithIndexM 3
zipWithIndex 1
unorderedTraverse 3
unorderedSequence 2
$init$ 0
unorderedFoldMap 3
unorderedFold 2
isEmpty 1
nonEmpty 1
exists 2
forall 2
size 1
<init> 0
<init> 0
combine 2
<init> 0
combine 2
commutativeMonoidEval 1
$init$ 0
unorderedTraverse 3
unorderedSequence 2
$init$ 0
lift 1
id 0
dimap 3
second 1
split 2
merge 2
$init$ 0
choose 2
left 1
right 1
choice 2
$init$ 0
id 0
algebraK 0
algebra 0
$init$ 0
choice 2
codiagonal 0
$init$ 0
compose 2
andThen 2
algebraK 0
algebra 0
$init$ 0
apply 1
compose 1
andThen 1
or 1
and 1
<init> 0
id 0
lift 1
<init> 0
lift 4
<init> 1
lift 3
unblock 1
punchHole 1
$init$ 0
dimap 3
lmap 2
rmap 2
first 1
second 1
<init> 1
dimap 3
lmap 2
map 1
contramapValue 1
flatMap 1
compose 2
andThen 2
first 1
second 1
<init> 0
pure 1
<init> 0
<init> 0
F 0
catsDataMonadForCokleisli 0
catsDataMonoidKForCokleisli 1
<init> 0
catsDataArrowForCokleisli 1
<init> 0
catsDataComposeForCokleisli 1
catsDataProfunctorForCokleisli 1
catsDataSemigroupKForCokleisli 1
catsDataContravariantForCokleisli 1
<init> 0
pure 1
flatMap 2
map 2
tailRecM 2
$init$ 0
F 0
lift 1
first 1
second 1
dimap 3
split 2
$init$ 0
F 0
compose 2
$init$ 0
F 0
dimap 3
lmap 2
rmap 2
<init> 1
retag 0
combine 2
traverse 2
$eq$eq$eq 2
partialCompare 2
compare 2
show 1
<init> 0
empty 1
<init> 1
apply 1
of 0
<init> 0
catsDataOrderForConst 1
catsDataShowForConst 1
catsDataContravariantMonoidalForConst 1
catsDataTraverseForConst 0
catsDataMonoidForConst 1
<init> 0
bifoldLeft 4
bifoldRight 4
<init> 0
catsDataSemigroupForConst 1
catsDataContravariantForConst 0
catsDataPartialOrderForConst 1
catsDataApplicativeForConst 1
<init> 0
catsDataEqForConst 1
catsDataApplyForConst 1
<init> 1
map 3
mapK 1
coflatMap 3
coflatten 2
extract 2
contramap 3
foldRight 4
foldLeft 4
foldMap 4
traverse 4
isLeft 0
isRight 0
swap 0
toValidated 0
fold 2
<init> 0
leftc 1
rightc 1
<init> 0
apply 1
<init> 0
apply 1
left 0
right 0
<init> 0
catsDataEqForEitherK 1
catsDataFunctorForEitherK 2
catsDataFoldableForEitherK 2
<init> 0
catsDataContravariantForEitherK 2
<init> 0
catsDataCoflatMapForEitherK 2
<init> 0
catsDataTraverseForEitherK 2
<init> 0
catsDataComonadForEitherK 2
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
foldRight 3
foldLeft 3
size 1
get 2
foldMap 3
$init$ 0
F 0
G 0
map 2
traverse 3
$init$ 0
F 0
G 0
map 2
coflatMap 2
coflatten 1
$init$ 0
F 0
G 0
extract 1
<init> 1
fold 3
isLeft 1
isRight 1
swap 1
getOrElse 2
getOrElseF 2
orElse 2
recover 2
recoverWith 2
valueOr 2
forall 2
exists 2
ensure 3
ensureOr 3
toOption 1
to 2
collectRight 2
bimap 3
bitraverse 4
applyAlt 2
flatMap 2
flatMapF 2
transform 2
subflatMap 2
map 2
mapK 1
semiflatMap 2
leftMap 2
leftFlatMap 2
leftSemiflatMap 2
compare 2
partialCompare 2
$eq$eq$eq 2
traverse 3
foldLeft 3
foldRight 3
merge 2
combine 3
toValidated 1
toValidatedNel 1
withValidated 2
show 1
toNested 0
toNestedValidated 1
toNestedValidatedNel 1
<init> 0
<init> 1
apply 2
left 0
<init> 1
apply 2
leftT 0
<init> 1
apply 2
right 0
<init> 1
apply 2
pure 0
rightT 0
liftF 2
liftK 1
liftT 2
fromEither 0
<init> 1
apply 2
fromOption 0
<init> 1
apply 3
fromOptionF 3
cond 0
<init> 1
apply 4
<init> 0
catsDataOrderForEitherT 1
catsDataShowForEitherT 1
catsDataBifunctorForEitherT 1
catsDataTraverseForEitherT 1
catsMonoidForEitherT 1
<init> 0
catsSemigroupForEitherT 1
catsDataFoldableForEitherT 1
catsDataPartialOrderForEitherT 1
catsDataBitraverseForEitherT 1
catsDataMonadErrorForEitherT 1
<init> 0
catsDataMonadErrorFForEitherT 1
catsDataSemigroupKForEitherT 1
catsDataEqForEitherT 1
<init> 0
catsDataFunctorForEitherT 1
$init$ 0
combine 2
$init$ 0
empty 0
$init$ 0
combineK 2
$init$ 0
map 2
$init$ 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
handleErrorWith 2
raiseError 1
$init$ 0
handleErrorWith 2
handleError 2
raiseError 1
attempt 1
recover 2
recoverWith 2
$init$ 0
F0 0
foldLeft 3
foldRight 3
$init$ 0
F0 0
traverse 3
$init$ 0
F0 0
bifoldLeft 4
bifoldRight 4
$init$ 0
F0 0
bitraverse 4
$init$ 0
F0 0
eqv 2
$init$ 0
F0 0
partialCompare 2
$init$ 0
F0 0
compare 2
<init> 0
run 0
map 2
mapK 1
<init> 0
func 1
appFunc 2
<init> 0
catsDataApplicativeForFunc 1
<init> 0
catsDataApplyForFunc 1
<init> 0
catsDataFunctorForFunc 1
catsDataContravariantForFunc 1
$init$ 0
F 0
map 2
$init$ 0
F 0
contramap 2
$init$ 0
F 0
ap 2
product 2
$init$ 0
F 0
pure 1
<init> 0
F 0
product 1
compose 1
andThen 1
map 1
traverse 2
<init> 0
<init> 0
appFuncApplicative 1
$init$ 0
F 0
map 2
ap 2
product 2
pure 1
<init> 1
map 2
mapK 1
flatMap 2
flatMapF 2
foldLeft 3
foldRight 3
reduceLeftTo 3
reduceRightTo 3
traverse 3
nonEmptyTraverse 3
ap 2
<init> 0
pure 2
$init$ 0
map 2
$init$ 0
ap 2
map2Eval 3
$init$ 0
pure 1
$init$ 0
unit 0
contramap 2
product 2
$init$ 0
flatMap 2
tailRecM 2
$init$ 0
foldLeft 3
foldRight 3
size 1
get 2
$init$ 0
traverse 3
$init$ 0
nonEmptyTraverse 3
reduceLeftTo 3
reduceRightTo 3
<init> 0
catsDataCommutativeFlatMapForIdT 1
<init> 0
catsDataCommutativeMonadForIdT 1
<init> 0
catsDataContravariantMonoidalForIdT 1
<init> 0
catsDataFunctorForIdT 1
<init> 0
catsDataApplyForIdT 1
<init> 0
catsDataApplicativeForIdT 1
<init> 0
catsDataFlatMapForIdT 1
<init> 0
catsDataMonadForIdT 1
catsDataFoldableForIdT 1
<init> 0
catsDataTraverseForIdT 1
catsDataEqForIdT 1
<init> 0
catsDataNonEmptyTraverseForIdT 1
catsDataOrderForIdT 1
catsDataShowForIdT 1
<init> 1
contramap 2
local 2
map 2
mapK 2
bimap 3
dimap 3
mapWritten 2
flatMap 3
flatMapF 2
transform 2
transformF 3
transformS 3
modify 2
inspect 2
get 1
tell 3
written 1
reset 2
run 3
runEmpty 3
runA 3
runS 3
runL 3
runEmptyA 3
runEmptyS 3
runEmptyL 3
$init$ 0
pure 3
liftF 3
liftK 2
lift 3
inspect 3
inspectF 3
set 3
setF 3
ask 2
tell 2
tellF 2
get 2
<init> 0
apply 2
applyF 1
modify 3
modifyF 3
<init> 0
apply 2
applyF 1
modify 3
modifyF 3
<init> 0
apply 2
pure 2
modify 2
inspect 2
get 1
set 2
ask 1
tell 1
<init> 0
catsDataProfunctorForIRWST 1
catsDataBifunctorForIRWST 1
catsDataContravariantForIRWST 1
catsDataMonadErrorForIRWST 2
<init> 0
catsDataMonadForRWST 2
catsDataStrongForIRWST 1
<init> 0
catsDataAlternativeForIRWST 3
<init> 0
catsDataSemigroupKForIRWST 2
catsDataFunctorForIRWST 1
<init> 0
F 0
map 2
<init> 0
F 0
contramap 2
<init> 0
F 0
dimap 3
<init> 0
F 0
first 1
second 1
<init> 0
F 0
bimap 3
<init> 0
F 0
L 0
pure 1
flatMap 2
tailRecM 2
<init> 0
F 0
G 0
combineK 2
<init> 0
F 0
G 0
L 0
combineK 2
empty 0
pure 1
ap 2
<init> 0
F 0
raiseError 1
handleErrorWith 2
<init> 1
flatMap 2
flatMapF 2
map 2
mapK 2
contramap 2
bimap 3
dimap 3
run 2
runS 2
runA 2
runEmpty 2
runEmptyS 2
runEmptyA 2
transform 2
transformF 3
transformS 3
modify 2
inspect 2
get 1
$init$ 0
pure 2
liftF 2
liftK 1
lift 2
inspect 2
inspectF 2
get 1
<init> 0
apply 2
applyF 1
modify 2
modifyF 2
set 2
setF 2
<init> 0
apply 2
applyF 1
modify 2
modifyF 2
set 2
setF 2
<init> 0
catsDataAlternativeForIndexedStateT 2
<init> 0
catsDataMonadErrorForIndexedStateT 1
catsDataSemigroupKForIndexedStateT 2
<init> 0
catsDataMonadForIndexedStateT 1
<init> 0
catsDataFunctorForIndexedStateT 1
catsDataContravariantForIndexedStateT 1
catsDataProfunctorForIndexedStateT 1
catsDataBifunctorForIndexedStateT 1
<init> 0
catsDataStrongForIndexedStateT 1
<init> 0
apply 1
pure 1
modify 1
inspect 1
get 0
set 1
<init> 0
F 0
map 2
<init> 0
F 0
contramap 2
<init> 0
F 0
bimap 3
<init> 0
F 0
dimap 3
<init> 0
F 0
first 1
second 1
<init> 0
F 0
pure 1
flatMap 2
tailRecM 2
<init> 0
F 0
G 0
combineK 2
<init> 0
F 0
G 0
unit 0
contramap 2
product 2
contramap2 3
<init> 0
G 0
combineK 2
empty 0
<init> 0
F 0
raiseError 1
handleErrorWith 2
<init> 0
fold 3
putLeft 1
putRight 1
isLeft 0
isRight 0
isBoth 0
left 0
right 0
onlyLeft 0
onlyRight 0
onlyLeftOrRight 0
onlyBoth 0
pad 0
unwrap 0
toEither 0
toValidated 0
toOption 0
toList 0
to 1
swap 0
exists 1
forall 1
getOrElse 1
valueOr 2
bimap 2
map 1
leftMap 1
flatMap 2
foreach 1
traverse 2
foldLeft 2
foldRight 2
merge 2
mergeLeft 1
mergeRight 1
combine 3
$eq$eq$eq 3
show 2
<init> 0
<init> 1
<init> 1
<init> 2
<init> 0
catsDataEqForIor 2
catsDataShowForIor 2
catsDataSemigroupForIor 2
catsDataMonadErrorForIor 1
catsDataBifunctorForIor 0
catsDataParallelForIor 1
<init> 0
catsDataTraverseFunctorForIor 0
$init$ 0
left 1
right 1
both 2
leftNel 1
bothNel 2
fromOptions 2
fromEither 1
<init> 1
fold 4
isLeft 1
isRight 1
isBoth 1
swap 1
getOrElse 2
getOrElseF 2
valueOr 3
forall 2
exists 2
toOption 1
toEither 1
toNested 0
toNestedValidated 1
toValidated 1
to 2
collectRight 2
merge 3
show 1
map 2
mapK 1
bimap 3
leftMap 2
leftFlatMap 3
leftSemiflatMap 2
transform 2
applyAlt 3
flatMap 3
flatMapF 3
subflatMap 3
semiflatMap 2
traverse 3
foldLeft 3
foldRight 3
$eq$eq$eq 2
combine 4
<init> 0
<init> 1
apply 2
left 0
<init> 1
apply 2
leftT 0
<init> 1
apply 2
right 0
rightT 0
both 3
<init> 1
apply 3
bothT 0
<init> 1
apply 2
pure 0
liftF 2
liftK 1
<init> 1
apply 2
fromIor 0
<init> 1
apply 2
fromEither 0
fromEitherF 2
<init> 1
apply 3
fromOption 0
fromOptionF 3
<init> 1
apply 4
cond 0
condF 4
<init> 0
catsDataShowForIorT 1
catsDataBifunctorForIorT 1
catsDataTraverseForIorT 1
catsDataMonoidForIorT 1
catsDataParallelForIorTWithParallelEffect 2
<init> 0
catsDataSemigroupForIorT 1
catsDataFoldableForIorT 1
catsDataMonadErrorForIorT 2
catsDataParallelForIorTWithSequentialEffect 2
<init> 0
catsDataMonadErrorFForIorT 2
catsDataEqForIorT 1
<init> 0
catsDataFunctorForIorT 1
$init$ 0
F0 0
map 2
$init$ 0
F0 0
eqv 2
$init$ 0
A0 0
F0 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
raiseError 1
handleErrorWith 2
$init$ 0
F0 0
raiseError 1
handleErrorWith 2
$init$ 0
F0 0
combine 2
$init$ 0
F0 0
empty 0
$init$ 0
F0 0
foldLeft 3
foldRight 3
$init$ 0
F0 0
traverse 3
<init> 1
ap 2
dimap 3
map 2
mapF 1
mapK 1
flatMap 2
flatMapF 2
andThen 2
andThen 2
compose 2
compose 2
traverse 3
lift 1
local 1
transform 1
lower 1
first 1
second 1
tap 1
tapWith 2
toReader 0
apply 1
<init> 0
$init$ 0
liftF 1
liftK 0
lift 1
pure 2
ask 1
local 2
$init$ 0
endoSemigroupK 1
endoMonoidK 1
<init> 0
catsDataCommutativeMonadForKleisli 1
catsDataArrowChoiceForKleisli 1
<init> 0
catsDataMonoidForKleisli 1
catsDataMonadErrorForKleisli 1
catsDataMonadForKleisliId 0
catsDataContravariantMonoidalForKleisli 1
<init> 0
catsDataMonadForKleisli 1
catsDataCommutativeArrowForKleisli 1
catsDataParallelForKleisli 1
catsDataContravariantForKleisli 0
<init> 0
catsDataAlternativeForKleisli 1
<init> 0
catsDataMonoidKForKleisli 1
catsDataFlatMapForKleisli 1
catsDataChoiceForKleisli 1
catsDataComposeForKleisli 1
catsDataStrongForKleisli 1
catsDataSemigroupForKleisli 1
<init> 0
catsDataSemigroupKForKleisli 1
catsDataApplicativeErrorForKleisli 1
catsDataCommutativeFlatMapForKleisli 1
<init> 0
catsDataApplicativeForKleisli 1
<init> 0
catsDataApplyForKleisli 1
<init> 0
catsDataDistributiveForKleisli 1
<init> 0
catsDataFunctorForKleisli 1
F 0
$init$ 0
F 0
lift 1
split 2
choose 2
$init$ 0
F 0
lmap 2
rmap 2
dimap 3
first 1
second 1
$init$ 0
choice 2
$init$ 0
F 0
id 0
$init$ 0
F 0
compose 2
$init$ 0
FB 0
combine 2
$init$ 0
FB 0
empty 0
$init$ 0
F 0
combineK 2
$init$ 0
F 0
empty 0
F 0
$init$ 0
F 0
unit 0
contramap 2
product 2
F 0
$init$ 0
F 0
raiseError 1
handleErrorWith 2
F 0
$init$ 0
F 0
flatMap 2
tailRecM 2
$init$ 0
F 0
pure 1
$init$ 0
F 0
ap 2
product 2
$init$ 0
F 0
map 2
$init$ 0
F 0
distribute 3
map 2
<init> 1
mapK 1
<init> 0
<init> 0
catsDataEqForNested 1
catsDataNonEmptyTraverseForNested 2
catsDataContravariantMonoidalForApplicativeForNested 2
<init> 0
catsDataTraverseForNested 2
<init> 0
catsDataReducibleForNested 2
catsDataFunctorForContravariantForNested 2
<init> 0
catsDataFoldableForNested 2
catsDataContravariantForCovariantNested 2
<init> 0
catsDataAlternativeForNested 2
catsDataContravariantForContravariantNested 2
<init> 0
catsDataApplicativeErrorForNested 2
<init> 0
catsDataCommutativeApplicativeForNestedContravariant 2
catsDataMonoidKForNested 1
<init> 0
catsDataCommutativeApplyForNestedContravariant 2
catsDataSemigroupKForNested 1
<init> 0
catsDataApplicativeForNested 2
<init> 0
catsDataApplyForNested 2
catsDataDistributiveForNested 2
<init> 0
catsDataInvariantSemigroupalApplyForNested 2
<init> 0
catsDataFunctorForNested 2
<init> 0
catsDataInvariantForNested 2
<init> 0
catsDataInvariantForCovariantNested 2
<init> 0
catsDataInvariantForNestedContravariant 2
$init$ 0
FG 0
imap 3
$init$ 0
FG 0
map 2
$init$ 0
FG 0
ap 2
product 2
$init$ 0
FG 0
pure 1
<init> 0
G 0
AEF 0
FG 0
raiseError 1
handleErrorWith 2
$init$ 0
FG 0
combineK 2
$init$ 0
FG 0
empty 0
FG 0
$init$ 0
FG 0
foldLeft 3
foldRight 3
$init$ 0
FG 0
traverse 3
$init$ 0
FG 0
distribute 3
$init$ 0
FG 0
reduceLeftTo 3
reduceRightTo 3
$init$ 0
FG 0
nonEmptyTraverse 3
$init$ 0
FG 0
contramap 2
$init$ 0
FG 0
unit 0
contramap 2
product 2
$init$ 0
FG 0
imap 3
product 2
<init> 2
toList 0
last 0
init 0
size 0
length 0
map 1
$plus$plus 1
concat 1
concat 1
concatNel 1
flatMap 1
$colon$colon 1
prepend 1
$colon$colon$colon 1
filter 1
filterNot 1
collect 1
find 1
exists 1
forall 1
foldLeft 2
foldRight 2
reduceLeft 1
reduce 1
traverse 2
coflatMap 1
$eq$eq$eq 2
show 1
toString 0
distinct 1
reverse 0
zipWith 2
zipWithIndex 0
sortBy 2
sorted 1
groupBy 2
<init> 0
of 2
ofInitLast 2
one 1
fromList 1
fromListUnsafe 1
fromFoldable 2
fromReducible 2
<init> 1
<init> 0
apply 1
<init> 0
ap 2
map 2
product 2
zipNelEq 1
<init> 0
<init> 0
combineK 2
split 1
reduceLeft 2
reduce 2
map 2
pure 1
flatMap 2
coflatMap 2
extract 1
nonEmptyTraverse 3
traverse 3
foldLeft 3
foldRight 3
foldMap 3
tailRecM 2
fold 2
nonEmptyPartition 2
find 2
forall 2
exists 2
toList 1
toNonEmptyList 1
get 2
catsDataShowForNonEmptyList 1
catsDataSemigroupForNonEmptyList 0
catsDataOrderForNonEmptyList 1
catsDataNonEmptyParallelForNonEmptyList 0
<init> 0
catsDataPartialOrderForNonEmptyList 1
<init> 0
catsDataEqForNonEmptyList 1
$init$ 0
A0 0
eqv 2
$init$ 0
A0 0
partialCompare 2
<init> 0
A0 0
compare 2
<init> 1
get 1
getUnsafe 1
updated 2
updatedUnsafe 2
head 0
tail 0
last 0
init 0
filter 1
filterNot 1
collect 1
$plus$plus 1
$plus$plus$colon 1
concat 1
concatNev 1
append 1
$colon$plus 1
prepend 1
$plus$colon 1
find 1
exists 1
forall 1
foldLeft 2
foldRight 2
map 1
flatMap 1
reduceLeft 1
reduce 1
$eq$eq$eq 2
show 1
length 0
toString 0
distinct 1
zipWith 2
reverse 0
zipWithIndex 0
sortBy 2
sorted 1
<init> 0
<init> 0
combineK 2
split 1
size 1
reduceLeft 2
reduce 2
map 2
pure 1
flatMap 2
coflatMap 2
extract 1
nonEmptyTraverse 3
traverse 3
zipWithIndex 1
foldLeft 3
foldRight 3
foldMap 3
nonEmptyPartition 2
get 2
tailRecM 2
fold 2
find 2
forall 2
exists 2
toList 1
toNonEmptyList 1
catsDataEqForNonEmptyVector 1
catsDataShowForNonEmptyVector 1
catsDataSemigroupForNonEmptyVector 0
catsDataParallelForNonEmptyVector 0
<init> 0
apply 2
of 2
one 1
unapply 1
fromVector 1
fromVectorUnsafe 1
<init> 1
<init> 0
apply 1
<init> 0
ap 2
map 2
product 2
zipNevEq 1
<init> 2
unwrap 1
filter 3
combine 2
find 2
exists 2
forall 2
reduceLeft 2
foldLeft 3
foldRight 3
map 2
mapK 1
$eq$eq$eq 3
show 2
<init> 0
catsDataParallelForOneAnd 3
catsDataEqForOneAnd 2
catsDataShowForOneAnd 2
catsDataSemigroupKForOneAnd 1
catsDataSemigroupForOneAnd 1
catsDataReducibleForOneAnd 1
catsDataMonadForOneAnd 2
<init> 0
<init> 0
coflatMap 2
extract 1
map 2
<init> 0
catsDataFunctorForOneAnd 1
<init> 0
catsDataApplicativeForOneAnd 1
<init> 0
catsDataTraverseForOneAnd 1
<init> 0
catsDataNonEmptyTraverseForOneAnd 2
<init> 0
<init> 1
fold 3
cata 3
map 2
mapK 1
semiflatMap 2
mapFilter 2
flatMap 2
flatMapF 2
transform 2
subflatMap 2
getOrElse 2
getOrElseF 2
collect 2
exists 2
filter 2
withFilter 2
filterNot 2
forall 2
isDefined 1
isEmpty 1
orElse 2
orElseF 2
toRight 2
toLeft 2
show 1
compare 2
partialCompare 2
$eq$eq$eq 2
traverse 3
foldLeft 3
foldRight 3
toNested 0
<init> 0
<init> 1
apply 2
pure 0
some 0
none 1
fromOption 0
<init> 1
apply 2
liftF 2
liftK 1
<init> 0
catsDataMonadForOptionT 1
catsDataFoldableForOptionT 1
catsDataSemigroupForOptionT 1
catsDataOrderForOptionT 1
catsDataShowForOptionT 1
<init> 0
catsDataMonadErrorForOptionT 1
catsDataContravariantMonoidalForOptionT 1
catsDataSemigroupKForOptionT 1
catsDataMonoidForOptionT 1
catsDataPartialOrderForOptionT 1
<init> 0
catsDataMonoidKForOptionT 1
catsDataEqForOptionT 1
<init> 0
catsDataTraverseForOptionT 1
<init> 0
catsDataFunctorForOptionT 1
$init$ 0
F 0
map 2
$init$ 0
F 0
pure 1
flatMap 2
map 2
tailRecM 2
$init$ 0
F 0
raiseError 1
handleErrorWith 2
$init$ 0
F 0
unit 0
contramap 2
product 2
$init$ 0
F 0
foldLeft 3
foldRight 3
$init$ 0
F 0
traverse 3
$init$ 0
combine 2
$init$ 0
empty 0
$init$ 0
F 0
combineK 2
$init$ 0
empty 0
$init$ 0
F 0
eqv 2
$init$ 0
F 0
partialCompare 2
$init$ 0
F 0
compare 2
<init> 2
mapK 1
<init> 0
<init> 0
catsDataOrderForTuple2K 2
catsDataShowForTuple2K 2
catsDataContravariantMonoidalForTuple2k 2
<init> 0
catsDataTraverseForTuple2K 2
catsDataContravariantForTuple2K 2
catsDataEqForTuple2K 2
<init> 0
catsDataAlternativeForTuple2K 2
catsDataFoldableForTuple2K 2
<init> 0
catsDataMonadForTuple2K 2
catsDataMonoidKForTuple2K 2
<init> 0
catsDataCommutativeApplicativeForTuple2K 2
<init> 0
catsDataSemigroupKForTuple2K 2
catsDataCommutativeApplyForTuple2K 2
<init> 0
catsDataApplicativeForTuple2K 2
<init> 0
catsDataApplyForTuple2K 2
<init> 0
catsDataDistributiveForTuple2K 2
<init> 0
catsDataFunctorForTuple2K 2
$init$ 0
F 0
G 0
map 2
$init$ 0
F 0
G 0
distribute 3
map 2
$init$ 0
F 0
G 0
contramap 2
$init$ 0
F 0
G 0
unit 0
product 2
contramap 2
$init$ 0
F 0
G 0
ap 2
product 2
map2Eval 3
$init$ 0
F 0
G 0
pure 1
$init$ 0
F 0
G 0
combineK 2
$init$ 0
F 0
G 0
empty 0
F 0
G 0
$init$ 0
F 0
G 0
pure 1
flatMap 2
tailRecM 2
$init$ 0
F 0
G 0
foldLeft 3
foldRight 3
$init$ 0
F 0
G 0
traverse 3
$init$ 0
F 0
G 0
show 1
$init$ 0
F 0
G 0
compare 2
<init> 0
fold 2
isValid 0
isInvalid 0
foreach 1
getOrElse 1
valueOr 1
exists 1
forall 1
orElse 1
findValid 2
toEither 0
toOption 0
toIor 0
toList 0
toValidatedNel 0
withEither 1
bimap 2
compare 3
partialCompare 3
$eq$eq$eq 3
ap 2
product 2
map 1
leftMap 1
traverse 2
foldLeft 2
foldRight 2
show 2
andThen 1
combine 3
swap 0
merge 1
ensure 2
ensureOr 2
<init> 0
<init> 1
<init> 1
catchOnly 0
<init> 1
apply 3
<init> 0
catsDataSemigroupKForValidated 1
catsDataMonoidForValidated 2
catsDataOrderForValidated 2
catsDataShowForValidated 2
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
bimap 3
leftMap 2
catsDataApplicativeErrorForValidated 1
<init> 0
catsDataSemigroupForValidated 2
catsDataCommutativeApplicativeForValidated 1
catsDataPartialOrderForValidated 2
<init> 0
catsDataEqForValidated 2
catsDataTraverseFunctorForValidated 0
<init> 1
map 2
pure 1
ap 2
product 2
$init$ 0
invalid 1
invalidNel 1
valid 1
validNel 1
catchNonFatal 1
fromTry 1
fromEither 1
fromOption 2
fromIor 1
cond 3
condNel 3
<init> 1
tell 3
written 1
value 1
ap 3
map 2
mapK 1
contramap 2
flatMap 3
mapBoth 2
bimap 3
mapWritten 2
swap 1
reset 2
show 1
<init> 0
liftF 3
liftK 2
lift 3
<init> 0
catsDataCommutativeMonadForWriterT 2
<init> 0
catsDataMonadErrorForWriterT 2
catsDataParallelForWriterT 2
catsDataEqForWriterTId 2
catsDataBifunctorForWriterT 1
catsDataShowForWriterT 1
catsDataMonoidForWriterTId 2
<init> 0
catsDataMonadForWriterTId 1
catsDataEqForWriterT 1
catsDataSemigroupForWriterTId 2
<init> 0
catsDataMonadForWriterT 2
catsDataMonoidForWriterT 1
catsDataCoflatMapForWriterTId 0
<init> 0
catsDataFlatMapForWriterTId 1
<init> 0
catsDataFlatMapForWriterT1 2
catsDataSemigroupForWriterT 1
<init> 0
catsDataApplicativeErrorForWriterT 2
<init> 0
catsDataAlternativeForWriterT 2
catsDataContravariantMonoidalForWriterT 1
<init> 0
catsDataMonoidKForWriterT 1
catsDataFlatMapForWriterT2 2
catsDataContravariantForWriterT 1
<init> 0
catsDataSemigroupKForWriterT 1
catsDataApplicativeForWriterT 2
<init> 0
catsDataApplyForWriterT 2
<init> 0
catsDataCoflatMapForWriterT 1
$init$ 0
F0 0
map 2
$init$ 0
F0 0
contramap 2
$init$ 0
F0 0
L0 0
ap 2
map2Eval 3
product 2
$init$ 0
F0 0
L0 0
flatMap 2
tailRecM 2
$init$ 0
F0 0
L0 0
flatMap 2
tailRecM 2
$init$ 0
F0 0
L0 0
pure 1
F0 0
L0 0
$init$ 0
F0 0
raiseError 1
handleErrorWith 2
F0 0
$init$ 0
F0 0
combineK 2
$init$ 0
F0 0
empty 0
F0 0
$init$ 0
F0 0
unit 0
contramap 2
product 2
$init$ 0
F0 0
combine 2
$init$ 0
F0 0
empty 0
$init$ 0
coflatMap 2
$init$ 0
putT 3
put 3
tell 2
value 3
valueT 3
<init> 1
<init> 0
apply 1
<init> 0
map 2
ap 2
product 2
catsDataEqForZipList 1
<init> 1
<init> 0
apply 1
<init> 0
pure 1
map 2
ap 2
product 2
empty 0
combineK 2
catsDataEqForZipStream 1
<init> 1
<init> 0
apply 1
<init> 0
map 2
ap 2
catsDataEqForZipVector 1
<init> 0
NonEmptyStream 2
NonEmptyStream 2
<init> 0
apply 1
<init> 0
apply 2
value 2
tell 1
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
substitute 1
andThen 1
compose 1
coerce 1
<init> 0
<init> 0
id 0
compose 2
<init> 0
<init> 0
substitute 1
refl 0
witness 1
compose 2
reify 0
fromPredef 1
co 1
co2 1
co2_2 1
co3 1
co3_2 1
co3_3 1
onF 2
lift2 2
contra 1
contra1_2 1
contra2_2 1
contra1_3 1
contra2_3 1
contra3_3 1
conF 2
invF 3
<init> 0
substitute 1
andThen 1
compose 1
flip 0
lift 0
coerce 1
predefEq 0
<init> 0
<init> 0
substitute 1
refl 0
unsafeFromPredef 1
<init> 0
<init> 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
$init$ 0
catsStdShowForBitSet 0
$init$ 0
$init$ 0
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
catsStdInstancesForEither 0
catsStdSemigroupKForEither 0
catsStdShowForEither 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
extract 1
coflatMap 2
pure 1
flatMap 2
tailRecM 2
$init$ 0
function0Distributive 0
$init$ 0
catsStdContravariantMonoidalForFunction1 1
catsStdMonadForFunction1 0
<init> 0
choose 2
lift 1
first 1
split 2
compose 2
$init$ 0
catsStdContravariantForFunction1 0
catsStdDistributiveForFunction1 0
$init$ 0
catsStdInstancesForFuture 1
$init$ 0
catsStdMonoidForFuture 2
$init$ 0
catsStdSemigroupForFuture 2
<init> 1
map 2
coflatMap 2
<init> 2
<init> 2
$init$ 0
<init> 0
contramap 2
$init$ 0
catsSemigroupalForMonoid 0
<init> 0
product 2
imap 3
unit 0
<init> 0
product 2
imap 3
unit 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
tailRecM 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
partitionEither 3
get 2
exists 2
forall 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
filter_ 2
takeWhile_ 2
dropWhile_ 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForList 1
$init$ 0
catsStdShowForMap 2
catsStdInstancesForMap 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
tailRecM 2
map2 3
map2Eval 3
coflatMap 2
foldLeft 3
foldRight 3
raiseError 1
handleErrorWith 2
traverse 3
reduceLeftToOption 3
reduceRightToOption 3
reduceLeftOption 2
reduceRightOption 2
minimumOption 2
maximumOption 2
get 2
size 1
foldMap 3
find 2
exists 2
forall 2
toList 1
filter_ 2
takeWhile_ 2
dropWhile_ 2
isEmpty 1
collectFirst 2
collectFirstSome 2
catsStdShowForOption 1
$init$ 0
<init> 0
unit 0
contramap 2
product 2
$init$ 0
<init> 0
unit 0
contramap 2
product 2
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
$init$ 0
catsParallelForEitherValidated 1
catsParallelForOptionTNestedOption 1
catsStdNonEmptyParallelForZipList 0
catsStdNonEmptyParallelForZipVector 0
catsStdParallelForZipStream 0
catsParallelForEitherTNestedParallelValidated 2
$init$ 0
catsParallelForEitherTNestedValidated 2
$init$ 0
<init> 0
contramap 2
product 2
unit 0
$init$ 0
<init> 0
contramap 2
product 2
unit 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
tailRecM 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
get 2
exists 2
forall 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
filter_ 2
takeWhile_ 2
dropWhile_ 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForQueue 1
$init$ 0
<init> 0
unorderedTraverse 3
unorderedSequence 2
empty 0
combineK 2
unorderedFoldMap 3
unorderedFold 2
forall 2
isEmpty 1
catsStdShowForSet 1
$init$ 0
catsStdHashForSortedMap 3
catsStdCommutativeMonoidForSortedMap 2
catsStdShowForSortedMap 3
catsStdInstancesForSortedMap 1
$init$ 0
catsStdEqForSortedMap 2
$init$ 0
catsStdMonoidForSortedMap 2
<init> 3
hash 1
<init> 2
eqv 2
<init> 2
<init> 2
empty 0
combine 2
$init$ 0
<init> 0
combineK 2
foldLeft 3
foldRight 3
foldMap 3
get 2
size 1
exists 2
forall 2
isEmpty 1
fold 2
toList 1
reduceLeftOption 2
find 2
collectFirst 2
collectFirstSome 2
catsStdShowForSortedSet 1
catsKernelStdOrderForSortedSet 1
$init$ 0
catsKernelStdHashForSortedSet 2
catsKernelStdSemilatticeForSortedSet 1
<init> 1
compare 2
eqv 2
<init> 2
hash 1
eqv 2
<init> 1
empty 0
combine 2
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
map2 3
map2Eval 3
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
traverse 3
mapWithIndex 2
zipWithIndex 1
tailRecM 2
exists 2
forall 2
get 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForStream 1
$init$ 0
<init> 0
$init$ 0
$init$ 0
catsStdInstancesForTry 0
catsStdShowForTry 1
catsStdEqForTry 2
<init> 0
castFailure 1
$init$ 0
catsStdMonoidForTry 1
$init$ 0
catsStdSemigroupForTry 1
<init> 0
map 2
coflatMap 2
<init> 1
<init> 1
$init$ 0
<init> 0
bitraverse 4
bifoldLeft 4
bifoldRight 4
catsStdShowForTuple2 2
catsStdInstancesForTuple2 0
$init$ 0
catsStdCommutativeMonadForTuple2 1
$init$ 0
catsStdCommutativeFlatMapForTuple2 1
$init$ 0
catsStdMonadForTuple2 1
$init$ 0
catsStdFlatMapForTuple2 1
<init> 1
ap 2
product 2
map 2
flatMap 2
productR 2
productL 2
mproduct 2
tailRecM 2
$init$ 0
$init$ 0
<init> 0
empty 0
combineK 2
pure 1
map 2
flatMap 2
coflatMap 2
foldLeft 3
foldRight 3
foldMap 3
tailRecM 2
size 1
get 2
traverse 3
mapWithIndex 2
zipWithIndex 1
exists 2
isEmpty 1
foldM 4
fold 2
toList 1
reduceLeftOption 2
find 2
algebra 0
collectFirst 2
collectFirstSome 2
catsStdShowForVector 1
<init> 0
<init> 0
pure 1
extract 1
flatMap 2
coflatMap 2
tailRecM 2
distribute 3
map 2
ap 2
flatten 1
map2 3
lift 1
imap 3
foldLeft 3
foldRight 3
nonEmptyTraverse 3
foldMap 3
reduce 2
reduceLeftTo 3
reduceLeft 2
reduceLeftToOption 3
reduceRight 2
reduceRightTo 3
reduceRightToOption 3
reduceMap 3
size 1
get 2
isEmpty 1
$init$ 0
catsSyntaxDistributiveOps 2
<init> 1
distribute 3
cosequence 3
$init$ 0
catsSyntaxUnite 1
catsSyntaxAlternativeSeparate 1
catsSyntaxAlternativeGuard 1
<init> 1
unite 3
<init> 1
separate 3
<init> 1
guard 1
$init$ 0
catsSyntaxApplicativeId 1
catsSyntaxApplicative 1
<init> 1
pure 1
<init> 1
replicateA 2
unlessA 2
whenA 2
$init$ 0
catsSyntaxApplicativeErrorId 1
catsSyntaxApplicativeError 2
<init> 1
raiseError 1
<init> 1
handleError 2
handleErrorWith 2
attempt 1
attemptT 1
recover 2
recoverWith 2
onError 2
$init$ 0
catsSyntaxApply 2
catsSyntaxApplyOps 1
<init> 1
followedBy 2
forEffect 2
$init$ 0
catsSyntaxBitraverse 2
$init$ 0
catsSyntaxNestedBitraverse 2
<init> 1
bitraverse 4
<init> 1
bisequence 2
$init$ 0
catsSyntaxContravariantMonoidal 2
<init> 0
$init$ 0
catsSyntaxContravariantSemigroupal 2
$init$ 0
catsSyntaxEither 1
catsSyntaxEitherObject 1
catsSyntaxLeft 1
catsSyntaxRight 1
catsSyntaxEitherId 1
<init> 0
<init> 1
apply 3
<init> 1
foreach 1
getOrElse 1
orElse 1
recover 1
recoverWith 1
valueOr 1
forall 1
exists 1
ensure 2
ensureOr 2
toIor 0
toOption 0
toList 0
toTry 1
toValidated 0
toValidatedNel 0
withValidated 1
to 1
bimap 2
map 1
map2Eval 2
leftMap 1
flatMap 1
compare 3
partialCompare 3
$eq$eq$eq 3
traverse 2
foldLeft 2
foldRight 2
combine 2
show 2
ap 1
toEitherT 1
raiseOrPure 1
<init> 1
left 1
right 1
catchOnly 0
catchNonFatal 1
fromTry 1
fromOption 2
<init> 1
rightCast 0
<init> 1
leftCast 0
<init> 1
asLeft 0
asRight 0
<init> 0
leftCast 1
rightCast 1
$init$ 0
catsSyntaxEitherK 1
<init> 1
leftc 0
rightc 0
$init$ 0
catsSyntaxEq 2
<init> 2
$eq$eq$eq 1
$eq$bang$eq 1
$init$ 0
catsSyntaxFlatten 2
catsSyntaxIfM 2
catsSyntaxFlatMapIdOps 1
catsSyntaxFlatMapOps 2
<init> 1
$greater$greater$eq 2
$greater$greater 2
$less$less 2
followedByEval 2
forEffectEval 2
<init> 1
flatten 1
<init> 1
ifM 3
<init> 1
tailRecM 2
$init$ 0
catsSyntaxNestedFoldable 2
catsSyntaxFoldOps 2
<init> 1
sequence_ 2
foldK 2
<init> 1
foldl 3
foldr 3
$init$ 0
catsSyntaxGroup 2
<init> 2
$bar$minus$bar 1
remove 1
inverse 0
$init$ 0
catsSyntaxHash 2
<init> 2
hash 0
$init$ 0
catsSyntaxIorId 1
<init> 1
rightIor 0
leftIor 0
$init$ 0
catsSyntaxList 1
<init> 1
toNel 0
groupByNel 2
$init$ 0
catsSyntaxMonad 1
catsSyntaxMonadIdOps 1
<init> 1
whileM 3
whileM_ 2
untilM 3
untilM_ 2
iterateWhile 2
iterateUntil 2
<init> 1
iterateWhileM 3
iterateUntilM 3
$init$ 0
catsSyntaxMonadError 2
catsSyntaxMonadErrorRethrow 2
<init> 1
ensure 3
ensureOr 3
adaptError 2
<init> 1
rethrow 1
$init$ 0
catsSyntaxMonoid 2
<init> 1
isEmpty 2
$init$ 0
none 0
catsSyntaxOptionId 1
catsSyntaxOption 1
<init> 1
some 0
<init> 1
toInvalid 1
toInvalidNel 1
toValid 1
toValidNel 1
toRightIor 1
toLeftIor 1
orEmpty 1
$init$ 0
catsSyntaxOrder 2
<init> 2
compare 1
min 1
max 1
comparison 1
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
<init> 0
$init$ 0
catsSyntaxParallelTraverse 2
catsSyntaxParallelSequence 3
catsSyntaxParallelAp 2
<init> 1
parTraverse 4
<init> 1
parSequence 3
<init> 1
$amp$greater 2
$less$amp 2
$init$ 0
catsSyntaxPartialOrder 2
<init> 2
$greater 1
$greater$eq 1
$less 1
$less$eq 1
partialCompare 1
tryCompare 1
pmin 1
pmax 1
$init$ 0
catsSyntaxNestedReducible 2
<init> 1
reduceK 2
$init$ 0
catsSyntaxSemigroup 2
<init> 2
$bar$plus$bar 1
combine 1
combineN 1
$init$ 0
catsSyntaxSemigroupal 2
<init> 0
$bar$at$bar 1
$init$ 0
showInterpolator 1
$init$ 0
catsSyntaxValidatedId 1
<init> 1
valid 0
validNel 0
invalid 0
invalidNel 0
$init$ 0
catsSyntaxVectors 1
<init> 1
toNev 0
$init$ 0
catsSyntaxWriterId 1
<init> 1
tell 0
writer 1
<init> 2
tailForced 0
transform 3
map 2
mapBranchingRoot 2
mapBranchingS 2
mapBranchingT 2
coflatMap 2
coflatten 1
extract 0
forceTail 0
forceAll 1
<init> 0
unfold 3
cata 3
cataM 5
<init> 0
catsReducibleForCofree 1
<init> 0
catsTraverseForCofree 1
<init> 0
catsFreeComonadForCofree 1
$init$ 0
F 0
extract 1
coflatMap 2
coflatten 1
map 2
$init$ 0
F 0
foldMap 3
foldRight 3
foldLeft 3
reduceLeftTo 3
reduceRightTo 3
$init$ 0
F 0
traverse 3
<init> 0
k 0
run 1
foldMap 2
toYoneda 1
map 1
mapK 1
transform 1
<init> 0
lift 1
apply 2
unsafeApply 2
catsFreeFunctorForCoyoneda 0
<init> 0
map 1
mapK 1
flatMap 1
fold 3
step 0
resume 1
foldStep 3
go 2
run 1
runM 3
runTailRec 1
foldMap 2
compile 1
inject 1
toString 0
<init> 0
<init> 1
<init> 1
<init> 2
pure 1
liftF 1
roll 1
suspend 1
defer 1
mapK 1
compile 1
foldMap 2
inject 0
<init> 1
apply 2
injectRoll 2
match_ 3
catsFreeMonadForFree 0
$init$ 0
F 0
foldLeft 3
foldRight 3
$init$ 0
TraversableF 0
F 0
traverse 3
map 2
<init> 0
catsFreeFoldableForFree 1
catsFreeTraverseForFree 1
<init> 0
ap 1
map 1
map2 2
foldMap 2
fold 1
compile 1
flatCompile 1
analyze 2
monad 0
toString 0
<init> 0
foldArg 3
<init> 2
<init> 1
<init> 1
<init> 2
pure 1
ap 2
lift 1
freeApplicative 0
<init> 0
imap 2
product 1
foldMap 2
fold 1
compile 1
analyze 2
<init> 0
<init> 1
foldMap 2
<init> 1
foldMap 2
<init> 2
foldMap 2
<init> 3
foldMap 2
pure 1
lift 1
catsFreeInvariantMonoidal 0
<init> 0
map 2
mapK 1
flatMap 1
hoist 1
interpret 2
compile 2
foldMap 2
resume 2
runM 3
toM 1
step 0
toString 0
<init> 0
<init> 1
<init> 2
a 0
f 0
pure 2
suspend 2
defer 2
tailRecM 3
liftT 2
liftF 2
roll 2
compile 2
foldMap 2
<init> 0
catsFreeMonadErrorForFreeT 1
<init> 0
catsFreeMonadForFreeT 1
<init> 0
catsFreeFlatMapForFreeT 1
<init> 0
catsFreeAlternativeForFreeT 2
<init> 0
catsFreeSemigroupKForFreeT 2
$init$ 0
M 0
map 2
flatMap 2
tailRecM 2
$init$ 0
M 0
pure 1
$init$ 0
M 0
M1 0
empty 0
$init$ 0
M 0
M1 0
combineK 2
<init> 0
done 1
suspend 1
defer 1
delay 1
<init> 0
apply 1
run 0
toCoyoneda 0
map 1
mapK 1
<init> 0
catsFreeFunctorForYoneda 0
apply 2
<init> 0
<init> 0
cons 2
<init> 0
pureSemigroupKIsConsK 2
$init$ 0
empty 0
isEmpty 2
nonEmpty 2
<init> 0
apply 1
$init$ 0
iterableIsEmpty 1
$init$ 0
monoidIsEmpty 1
$init$ 0
empty 0
synthesize 0
<init> 0
<init> 0
instantiate 1
extract 1
<init> 0
comonadIsExtract 1
extractCoflatMapIsComonad 2
$init$ 0
one 0
isOne 2
nonOne 2
<init> 0
apply 1
pure 1
<init> 0
applicativeIsPure 1
pureFlatMapIsMonad 2
$init$ 0
zero 0
isZero 2
nonZero 2
<init> 0
apply 1
<init> 0
<init> 0
<init> 0
<init> 0
foldLeft 3
foldRight 3
foldMap 3
$init$ 0
legacyIterableFoldable 1
<init> 0
<init> 0
<init> 0
empty 0
<init> 0
cons 2
$init$ 0
alleycatsStdInstancesForMap 0
<init> 0
<init> 0
<init> 0
empty 0
<init> 0
<init> 0
pure 1
map 2
flatMap 2
tailRecM 2
<init> 0
foldLeft 3
foldRight 3
foldMap 3
traverse 3
get 2
size 1
exists 2
forall 2
isEmpty 1
fold 2
toList 1
reduceLeftOption 2
find 2
collectFirst 2
collectFirstSome 2
<init> 0
$init$ 0
legacySetMonad 1
legacySetTraverse 1
<init> 0
<init> 0
<init> 0
pure 1
map 2
flatMap 2
coflatMap 2
extract 1
tailRecM 2
$init$ 0
legacyTryBimonad 1
<init> 0
<init> 0
$init$ 0
<init> 2
isEmpty 1
nonEmpty 1
<init> 0
$init$ 0
<init> 2
foreach 1
$init$ 0
F 0
algebra 0
alternativeRightAbsorption 1
alternativeLeftDistributivity 3
alternativeRightDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
applicativeErrorHandleWith 2
applicativeErrorHandle 2
handleErrorWithPure 2
handleErrorPure 2
raiseErrorAttempt 1
pureAttempt 1
handleErrorWithConsistentWithRecoverWith 2
handleErrorConsistentWithRecover 2
recoverConsistentWithRecoverWith 2
attemptConsistentWithAttemptT 1
attemptFromEitherConsistentWithPure 1
onErrorPure 2
onErrorRaise 3
<init> 0
apply 1
$init$ 0
F 0
applicativeIdentity 1
applicativeHomomorphism 2
applicativeInterchange 2
applicativeMap 2
applicativeComposition 3
apProductConsistent 2
applicativeUnit 1
monoidalLeftIdentity 1
monoidalRightIdentity 1
<init> 0
apply 1
$init$ 0
F 0
applyComposition 3
map2ProductConsistency 3
map2EvalConsistency 3
productRConsistency 2
productLConsistency 2
<init> 0
apply 1
$init$ 0
F 0
Function 0
sumAssoc 1
leftLiftCommute 1
leftComposeCommute 2
leftRightConsistent 1
leftAndThenLiftedLeftApplyCommutes 1
leftAndThenRightIdentityCommutes 2
leftTwiceCommutesWithSumAssociation 1
<init> 0
apply 2
$init$ 0
F 0
arrowIdentity 0
arrowComposition 2
arrowExtension 1
arrowFunctor 2
arrowExchange 2
arrowUnit 1
arrowAssociation 1
splitConsistentWithAndThen 2
mergeConsistentWithAndThen 2
fst 1
assoc 1
<init> 0
apply 1
$init$ 0
F 0
bifoldLeftConsistentWithBifoldMap 4
bifoldRightConsistentWithBifoldMap 4
<init> 0
apply 1
$init$ 0
F 0
bifunctorIdentity 1
bifunctorComposition 5
bifunctorLeftMapIdentity 1
bifunctorLeftMapComposition 3
<init> 0
apply 1
$init$ 0
F 0
pureExtractIsId 1
extractFlatMapEntwining 1
pureCoflatMapEntwining 1
<init> 0
apply 1
$init$ 0
F 0
bitraverseIdentity 1
bitraverseCompose 6
<init> 0
apply 1
$init$ 0
F 0
categoryLeftIdentity 1
categoryRightIdentity 1
<init> 0
apply 1
$init$ 0
F 0
choiceCompositionDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
coflatMapAssociativity 3
coflattenThroughMap 1
coflattenCoherence 2
coflatMapIdentity 1
cokleisliAssociativity 4
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
applyCommutative 3
<init> 0
apply 1
$init$ 0
F 0
arrowCommutative 2
<init> 0
apply 1
$init$ 0
F 0
flatmapCommutative 3
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
extractCoflattenIdentity 1
mapCoflattenIdentity 1
mapCoflatMapCoherence 2
comonadLeftIdentity 1
comonadRightIdentity 2
cokleisliLeftIdentity 2
cokleisliRightIdentity 2
<init> 0
apply 1
$init$ 0
F 0
composeAssociativity 3
<init> 0
apply 1
$init$ 0
F 0
contravariantIdentity 1
contravariantComposition 3
<init> 0
apply 1
$init$ 0
F 0
contravariantMonoidalUnitRight 1
contravariantMonoidalUnitLeft 1
contravariantMonoidalContramap2CompatibleContramapLeft 2
contravariantMonoidalContramap2CompatibleContramapRight 2
<init> 0
apply 1
$init$ 0
F 0
delta 1
contravariantSemigroupalContramap2DiagonalAssociates 3
<init> 0
apply 1
$init$ 0
F 0
distributeIdentity 2
cosequenceIdentity 1
cosequenceTwiceIsId 2
composition 5
<init> 0
apply 1
$init$ 0
F 0
flatMapAssociativity 3
flatMapConsistentApply 2
kleisliAssociativity 4
mproductConsistency 2
tailRecMConsistentFlatMap 2
flatMapFromTailRecMConsistency 2
<init> 0
apply 1
$init$ 0
F 0
leftFoldConsistentWithFoldMap 3
rightFoldConsistentWithFoldMap 3
existsConsistentWithFind 2
foldMIdentity 3
reduceLeftOptionConsistentWithReduceLeftToOption 2
reduceRightOptionConsistentWithReduceRightToOption 2
getRef 2
foldRef 2
toListRef 1
filter_Ref 2
takeWhile_Ref 2
dropWhile_Ref 2
collectFirstSome_Ref 2
collectFirst_Ref 2
orderedConsistency 4
<init> 0
apply 1
$init$ 0
F 0
covariantIdentity 1
covariantComposition 3
<init> 0
apply 1
$init$ 0
injectK 0
injectKRoundTripInj 1
injectKRoundTripPrj 1
<init> 0
apply 1
$init$ 0
inject 0
injectRoundTripInj 1
injectRoundTripPrj 1
<init> 0
apply 1
$init$ 0
F 0
invariantIdentity 1
invariantComposition 5
<init> 0
apply 1
$init$ 0
F 0
invariantMonoidalLeftIdentity 1
invariantMonoidalRightIdentity 1
invariantMonoidalAssociativity 3
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
monadErrorLeftZero 2
monadErrorEnsureConsistency 3
monadErrorEnsureOrConsistency 3
adaptErrorPure 2
adaptErrorRaise 2
rethrowAttempt 1
<init> 0
apply 1
$init$ 0
F 0
monadLeftIdentity 2
monadRightIdentity 1
kleisliLeftIdentity 2
kleisliRightIdentity 2
mapFlatMapCoherence 2
<init> 0
apply 1
$init$ 0
F 0
monoidKLeftIdentity 1
monoidKRightIdentity 1
<init> 0
apply 1
$init$ 0
P 0
parallelRoundTrip 1
sequentialRoundTrip 1
isomorphicFunctor 2
<init> 0
apply 1
$init$ 0
F 0
nonEmptyTraverseIdentity 2
nonEmptyTraverseSequentialComposition 5
nonEmptyTraverseParallelComposition 5
reduceMapDerived 3
<init> 0
apply 1
$init$ 0
P 0
isomorphicPure 1
<init> 0
apply 1
$init$ 0
F 0
profunctorIdentity 1
profunctorComposition 5
profunctorLmapIdentity 1
profunctorRmapIdentity 1
profunctorLmapComposition 3
profunctorRmapComposition 3
<init> 0
apply 1
$init$ 0
F 0
reduceLeftToConsistentWithReduceMap 3
reduceRightToConsistentWithReduceMap 3
reduceRightToConsistentWithReduceRightToOption 3
reduceRightConsistentWithReduceRightOption 2
reduceReduceLeftConsistent 2
traverseConsistent 3
sequenceConsistent 2
sizeConsistent 1
<init> 0
apply 1
$init$ 0
F 0
semigroupKAssociative 3
<init> 0
apply 1
$init$ 0
F 0
semigroupalAssociativity 3
<init> 0
apply 1
$init$ 0
F 0
strongFirstDistributivity 3
strongSecondDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
traverseIdentity 2
traverseSequentialComposition 5
traverseParallelComposition 5
foldMapDerived 3
traverseOrderConsistent 1
mapWithIndexRef 2
traverseWithIndexMRef 3
zipWithIndexRef 2
<init> 0
apply 1
$init$ 0
F 0
unorderedFoldConsistentWithUnorderedFoldMap 2
forallConsistentWithExists 2
existsLazy 1
forallLazy 1
forallEmpty 2
nonEmptyRef 1
<init> 0
apply 1
$init$ 0
F 0
unorderedTraverseIdentity 3
unorderedTraverseSequentialComposition 5
unorderedTraverseParallelComposition 5
unorderedSequenceConsistent 2
<init> 0
apply 1
$init$ 0
laws 0
alternative 16
<init> 0
apply 1
$init$ 0
laws 0
applicativeError 26
<init> 0
apply 1
$init$ 0
laws 0
applicative 16
<init> 0
apply 1
$init$ 0
laws 0
apply 15
<init> 0
apply 1
<init> 0
catsLawsCogenForTry 1
catsLawsCogenForFunction0 1
catsLawsArbitraryForConst 1
catsLawsCogenForConst 1
catsLawsArbitraryForOneAnd 2
catsLawsCogenForOneAnd 2
catsLawsArbitraryForNonEmptyVector 1
catsLawsCogenForNonEmptyVector 1
catsLawsArbitraryForZipVector 1
catsLawsArbitraryForZipList 1
catsLawsArbitraryForZipStream 1
catsLawsArbitraryForZipNonEmptyVector 1
catsLawsArbitraryForNonEmptyList 1
catsLawsCogenForNonEmptyList 1
catsLawsArbitraryForZipNonEmptyList 1
catsLawsArbitraryForEitherT 1
catsLawsCogenForEitherT 1
catsLawsArbitraryForValidated 2
catsLawsCogenForValidated 2
catsLawsArbitraryForIor 2
catsLawsCogenForIor 2
catsLawsArbitraryForIorT 1
catsLawsCogenForIorT 1
catsLawsArbitraryForOptionT 1
catsLawsCogenForOptionT 1
catsLawsArbitraryForIdT 1
catsLawsCogenForIdT 1
catsLawsArbitraryForEval 1
catsLawsCogenForEval 1
catsLawsArbitraryForTuple2K 2
catsLawsArbitraryForFunc 3
catsLawsArbitraryForAppFunc 4
catsLawsArbitraryForWriter 2
catsLawsCogenForWriter 2
catsLawsArbitraryForPartialFunction 1
catsLawsArbitraryForEitherK 2
catsLawsCogenForEitherK 2
catLawsCogenForTuple2K 2
catsLawsArbitraryForShow 1
catsLawsArbitraryForFn0 1
catsLawsArbitraryForEq 1
catsLawsArbitraryForEquiv 1
catsLawsArbitraryForPartialOrder 1
catsLawsArbitraryForPartialOrdering 1
catsLawsArbitraryForOrder 1
catsLawsArbitraryForSortedMap 3
catsLawsCogenForSortedMap 4
catsLawsArbitraryForSortedSet 2
catsLawsCogenForSortedSet 2
catsLawsArbitraryForOrdering 1
catsLawsArbitraryForHash 1
catsLawsArbitraryForNested 1
catsLawArbitraryForState 3
catsLawArbitraryForReader 3
catsLawArbitraryForCokleisliId 3
catsLawsArbitraryForIRWST 2
$init$ 0
catsLawArbitraryForIndexedStateT 1
catsLawsArbitraryForWriterT 1
catsLawsCogenForWriterT 1
catsLawsArbitraryForKleisli 3
catsLawsArbitraryForCokleisli 3
$init$ 0
laws 0
arrowChoice 39
<init> 0
apply 1
$init$ 0
laws 0
arrow 31
<init> 0
apply 1
$init$ 0
laws 0
bifoldable 8
<init> 0
apply 1
$init$ 0
laws 0
bifunctor 9
<init> 0
apply 1
$init$ 0
laws 0
bimonad 25
<init> 0
apply 1
$init$ 0
laws 0
bitraverse 25
<init> 0
apply 1
$init$ 0
laws 0
category 5
<init> 0
apply 1
$init$ 0
laws 0
choice 7
<init> 0
apply 1
$init$ 0
laws 0
coflatMap 14
<init> 0
apply 1
$init$ 0
laws 0
commutativeApplicative 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeApply 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeArrow 31
<init> 0
apply 1
$init$ 0
laws 0
commutativeFlatMap 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeMonad 20
<init> 0
apply 1
$init$ 0
laws 0
comonad 17
<init> 0
apply 1
$init$ 0
laws 0
compose 4
<init> 0
apply 1
$init$ 0
laws 0
contravariantMonoidal 14
<init> 0
apply 1
$init$ 0
laws 0
contravariantSemigroupal 14
<init> 0
apply 1
$init$ 0
laws 0
contravariant 9
<init> 0
apply 1
$init$ 0
laws 0
distributive 20
<init> 0
apply 1
<init> 0
catsLawsEqForFn1 2
catsLawsEqForFn2 3
catsLawsEqForShow 1
sampledEq 4
catsLawsEqForEq 1
catsLawsEqForEquiv 1
catsLawsEqForPartialOrder 2
catsLawsEqForPartialOrdering 2
catsLawsEqForOrder 1
catsLawsEqForOrdering 1
catsLawsEqForHash 1
catsLawsEqForSemigroup 2
catsLawsEqForCommutativeSemigroup 2
catsLawsEqForBand 3
catsLawsEqForMonoid 2
catsLawsEqForSemilattice 3
catsLawsEqForCommutativeMonoid 3
catsLawsEqForBoundedSemilattice 3
catsLawsEqForGroup 3
catsLawsEqForCommutativeGroup 3
$init$ 0
laws 0
flatMap 16
<init> 0
apply 1
$init$ 0
laws 0
foldable 12
<init> 0
apply 1
$init$ 0
laws 0
functor 9
<init> 0
apply 1
$init$ 0
laws 0
injectK 4
<init> 0
apply 1
$init$ 0
laws 0
inject 4
<init> 0
apply 1
$init$ 0
laws 0
invariantMonoidal 14
<init> 0
apply 1
$init$ 0
laws 0
invariantSemigroupal 14
<init> 0
apply 1
$init$ 0
laws 0
invariant 9
<init> 0
apply 1
$init$ 0
laws 0
monadError 27
<init> 0
apply 1
$init$ 0
laws 0
monad 20
stackUnsafeMonad 20
<init> 0
apply 1
$init$ 0
laws 0
monoidK 3
<init> 0
apply 1
$init$ 0
laws 0
nonEmptyParallel 8
<init> 0
apply 1
$init$ 0
laws 0
nonEmptyTraverse 38
<init> 0
apply 1
$init$ 0
laws 0
parallel 8
<init> 0
apply 1
$init$ 0
laws 0
profunctor 16
<init> 0
apply 1
$init$ 0
laws 0
reducible 16
<init> 0
apply 1
$init$ 0
laws 0
semigroupK 3
<init> 0
apply 1
$init$ 0
laws 0
semigroupal 9
<init> 0
apply 2
associativity 1
leftIdentity 1
rightIdentity 1
<init> 0
invariant 1
$init$ 0
laws 0
strong 19
<init> 0
apply 1
$init$ 0
laws 0
traverse 30
<init> 0
apply 1
$init$ 0
laws 0
unorderedFoldable 9
<init> 0
apply 1
$init$ 0
laws 0
unorderedTraverse 19
<init> 0
apply 1
<init> 0
catsLawsIsEqToProp 3
<init> 0
<init> 1
$less$minus$greater 1
$init$ 0
laws 0
tailRecM 4
<init> 0
apply 1
<init> 0
fold 0
traverseConst 0
<init> 0
combineAllCats 0
combineCats 0
combineScalaz 0
combineDirect 0
combineGeneric 0
combineMapsGeneric 3
foldMapCats 0
foldMapScalaz 0
<init> 0
eval 0
evalFib 1
trampoline 0
trampolineFib 1
<init> 1
areEquivalent 2
$init$ 0
lowPriorityCatsCanEqual 2
$init$ 0
convertToEqualizer 1
convertToCheckingEqualizer 1
unconstrainedEquality 1
catsCanEqual 2
<init> 0
$init$ 0
$init$ 0
catsSyntaxEq 2
even 1
$init$ 0
<init> 0
<init> 0
n 0
<init> 1
$init$ 0
<init> 1
<init> 1
<init> 0
<init> 1
<init> 0
<init> 0
partialCompare 2
<init> 1
<init> 0
<init> 0
compare 2
<init> 1
<init> 0
<init> 0
hash 1
eqv 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
inverse 1
<init> 1
<init> 0
<init> 0
empty 0
combine 2
inverse 1
<init> 0
<init> 0
result 2
$init$ 0
futureComonad 2
futureOrder 3
$init$ 0
futurePartialOrder 3
$init$ 0
futureEq 3
cons 2
<init> 0
pureSemigroupKIsConsK 2
$init$ 0
empty 0
isEmpty 2
nonEmpty 2
<init> 0
apply 1
$init$ 0
iterableIsEmpty 1
$init$ 0
monoidIsEmpty 1
$init$ 0
empty 0
synthesize 0
<init> 0
<init> 0
instantiate 1
extract 1
<init> 0
comonadIsExtract 1
extractCoflatMapIsComonad 2
$init$ 0
one 0
isOne 2
nonOne 2
<init> 0
apply 1
pure 1
<init> 0
applicativeIsPure 1
pureFlatMapIsMonad 2
$init$ 0
zero 0
isZero 2
nonZero 2
<init> 0
apply 1
<init> 0
<init> 0
<init> 0
<init> 0
foldLeft 3
foldRight 3
foldMap 3
$init$ 0
legacyIterableFoldable 1
<init> 0
<init> 0
<init> 0
empty 0
<init> 0
cons 2
$init$ 0
alleycatsStdInstancesForMap 0
<init> 0
<init> 0
<init> 0
empty 0
<init> 0
<init> 0
pure 1
map 2
flatMap 2
tailRecM 2
<init> 0
foldLeft 3
foldRight 3
foldMap 3
traverse 3
get 2
size 1
exists 2
forall 2
isEmpty 1
fold 2
toList 1
reduceLeftOption 2
find 2
collectFirst 2
collectFirstSome 2
<init> 0
$init$ 0
legacySetMonad 1
legacySetTraverse 1
<init> 0
<init> 0
<init> 0
pure 1
map 2
flatMap 2
coflatMap 2
extract 1
tailRecM 2
$init$ 0
legacyTryBimonad 1
<init> 0
<init> 0
$init$ 0
<init> 2
isEmpty 1
nonEmpty 1
<init> 0
$init$ 0
<init> 2
foreach 1
<init> 2
tailForced 0
transform 3
map 2
mapBranchingRoot 2
mapBranchingS 2
mapBranchingT 2
coflatMap 2
coflatten 1
extract 0
forceTail 0
forceAll 1
<init> 0
unfold 3
cata 3
cataM 5
<init> 0
catsReducibleForCofree 1
<init> 0
catsTraverseForCofree 1
<init> 0
catsFreeComonadForCofree 1
$init$ 0
F 0
extract 1
coflatMap 2
coflatten 1
map 2
$init$ 0
F 0
foldMap 3
foldRight 3
foldLeft 3
reduceLeftTo 3
reduceRightTo 3
$init$ 0
F 0
traverse 3
<init> 0
k 0
run 1
foldMap 2
toYoneda 1
map 1
mapK 1
transform 1
<init> 0
lift 1
apply 2
unsafeApply 2
catsFreeFunctorForCoyoneda 0
<init> 0
map 1
mapK 1
flatMap 1
fold 3
step 0
resume 1
foldStep 3
go 2
run 1
runM 3
runTailRec 1
foldMap 2
compile 1
inject 1
toString 0
<init> 0
<init> 1
<init> 1
<init> 2
pure 1
liftF 1
roll 1
suspend 1
defer 1
mapK 1
compile 1
foldMap 2
inject 0
<init> 1
apply 2
injectRoll 2
match_ 3
catsFreeMonadForFree 0
$init$ 0
F 0
foldLeft 3
foldRight 3
$init$ 0
TraversableF 0
F 0
traverse 3
map 2
<init> 0
catsFreeFoldableForFree 1
catsFreeTraverseForFree 1
<init> 0
ap 1
map 1
map2 2
foldMap 2
fold 1
compile 1
flatCompile 1
analyze 2
monad 0
toString 0
<init> 0
foldArg 3
<init> 2
<init> 1
<init> 1
<init> 2
pure 1
ap 2
lift 1
freeApplicative 0
<init> 0
imap 2
product 1
foldMap 2
fold 1
compile 1
analyze 2
<init> 0
<init> 1
foldMap 2
<init> 1
foldMap 2
<init> 2
foldMap 2
<init> 3
foldMap 2
pure 1
lift 1
catsFreeInvariantMonoidal 0
<init> 0
map 2
mapK 1
flatMap 1
hoist 1
interpret 2
compile 2
foldMap 2
resume 2
runM 3
toM 1
step 0
toString 0
<init> 0
<init> 1
<init> 2
a 0
f 0
pure 2
suspend 2
defer 2
tailRecM 3
liftT 2
liftF 2
roll 2
compile 2
foldMap 2
<init> 0
catsFreeMonadErrorForFreeT 1
<init> 0
catsFreeMonadForFreeT 1
<init> 0
catsFreeFlatMapForFreeT 1
<init> 0
catsFreeAlternativeForFreeT 2
<init> 0
catsFreeSemigroupKForFreeT 2
$init$ 0
M 0
map 2
flatMap 2
tailRecM 2
$init$ 0
M 0
pure 1
$init$ 0
M 0
M1 0
empty 0
$init$ 0
M 0
M1 0
combineK 2
<init> 0
done 1
suspend 1
defer 1
delay 1
<init> 0
apply 1
run 0
toCoyoneda 0
map 1
mapK 1
<init> 0
catsFreeFunctorForYoneda 0
apply 2
<init> 0
<init> 0
$init$ 0
F 0
algebra 0
alternativeRightAbsorption 1
alternativeLeftDistributivity 3
alternativeRightDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
applicativeErrorHandleWith 2
applicativeErrorHandle 2
handleErrorWithPure 2
handleErrorPure 2
raiseErrorAttempt 1
pureAttempt 1
handleErrorWithConsistentWithRecoverWith 2
handleErrorConsistentWithRecover 2
recoverConsistentWithRecoverWith 2
attemptConsistentWithAttemptT 1
attemptFromEitherConsistentWithPure 1
onErrorPure 2
onErrorRaise 3
<init> 0
apply 1
$init$ 0
F 0
applicativeIdentity 1
applicativeHomomorphism 2
applicativeInterchange 2
applicativeMap 2
applicativeComposition 3
apProductConsistent 2
applicativeUnit 1
monoidalLeftIdentity 1
monoidalRightIdentity 1
<init> 0
apply 1
$init$ 0
F 0
applyComposition 3
map2ProductConsistency 3
map2EvalConsistency 3
productRConsistency 2
productLConsistency 2
<init> 0
apply 1
$init$ 0
F 0
Function 0
sumAssoc 1
leftLiftCommute 1
leftComposeCommute 2
leftRightConsistent 1
leftAndThenLiftedLeftApplyCommutes 1
leftAndThenRightIdentityCommutes 2
leftTwiceCommutesWithSumAssociation 1
<init> 0
apply 2
$init$ 0
F 0
arrowIdentity 0
arrowComposition 2
arrowExtension 1
arrowFunctor 2
arrowExchange 2
arrowUnit 1
arrowAssociation 1
splitConsistentWithAndThen 2
mergeConsistentWithAndThen 2
fst 1
assoc 1
<init> 0
apply 1
$init$ 0
F 0
bifoldLeftConsistentWithBifoldMap 4
bifoldRightConsistentWithBifoldMap 4
<init> 0
apply 1
$init$ 0
F 0
bifunctorIdentity 1
bifunctorComposition 5
bifunctorLeftMapIdentity 1
bifunctorLeftMapComposition 3
<init> 0
apply 1
$init$ 0
F 0
pureExtractIsId 1
extractFlatMapEntwining 1
pureCoflatMapEntwining 1
<init> 0
apply 1
$init$ 0
F 0
bitraverseIdentity 1
bitraverseCompose 6
<init> 0
apply 1
$init$ 0
F 0
categoryLeftIdentity 1
categoryRightIdentity 1
<init> 0
apply 1
$init$ 0
F 0
choiceCompositionDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
coflatMapAssociativity 3
coflattenThroughMap 1
coflattenCoherence 2
coflatMapIdentity 1
cokleisliAssociativity 4
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
applyCommutative 3
<init> 0
apply 1
$init$ 0
F 0
arrowCommutative 2
<init> 0
apply 1
$init$ 0
F 0
flatmapCommutative 3
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
extractCoflattenIdentity 1
mapCoflattenIdentity 1
mapCoflatMapCoherence 2
comonadLeftIdentity 1
comonadRightIdentity 2
cokleisliLeftIdentity 2
cokleisliRightIdentity 2
<init> 0
apply 1
$init$ 0
F 0
composeAssociativity 3
<init> 0
apply 1
$init$ 0
F 0
contravariantIdentity 1
contravariantComposition 3
<init> 0
apply 1
$init$ 0
F 0
contravariantMonoidalUnitRight 1
contravariantMonoidalUnitLeft 1
contravariantMonoidalContramap2CompatibleContramapLeft 2
contravariantMonoidalContramap2CompatibleContramapRight 2
<init> 0
apply 1
$init$ 0
F 0
delta 1
contravariantSemigroupalContramap2DiagonalAssociates 3
<init> 0
apply 1
$init$ 0
F 0
distributeIdentity 2
cosequenceIdentity 1
cosequenceTwiceIsId 2
composition 5
<init> 0
apply 1
$init$ 0
F 0
flatMapAssociativity 3
flatMapConsistentApply 2
kleisliAssociativity 4
mproductConsistency 2
tailRecMConsistentFlatMap 2
flatMapFromTailRecMConsistency 2
<init> 0
apply 1
$init$ 0
F 0
leftFoldConsistentWithFoldMap 3
rightFoldConsistentWithFoldMap 3
existsConsistentWithFind 2
foldMIdentity 3
reduceLeftOptionConsistentWithReduceLeftToOption 2
reduceRightOptionConsistentWithReduceRightToOption 2
getRef 2
foldRef 2
toListRef 1
filter_Ref 2
takeWhile_Ref 2
dropWhile_Ref 2
collectFirstSome_Ref 2
collectFirst_Ref 2
orderedConsistency 4
<init> 0
apply 1
$init$ 0
F 0
covariantIdentity 1
covariantComposition 3
<init> 0
apply 1
$init$ 0
injectK 0
injectKRoundTripInj 1
injectKRoundTripPrj 1
<init> 0
apply 1
$init$ 0
inject 0
injectRoundTripInj 1
injectRoundTripPrj 1
<init> 0
apply 1
$init$ 0
F 0
invariantIdentity 1
invariantComposition 5
<init> 0
apply 1
$init$ 0
F 0
invariantMonoidalLeftIdentity 1
invariantMonoidalRightIdentity 1
invariantMonoidalAssociativity 3
<init> 0
apply 1
F 0
<init> 0
apply 1
$init$ 0
F 0
monadErrorLeftZero 2
monadErrorEnsureConsistency 3
monadErrorEnsureOrConsistency 3
adaptErrorPure 2
adaptErrorRaise 2
rethrowAttempt 1
<init> 0
apply 1
$init$ 0
F 0
monadLeftIdentity 2
monadRightIdentity 1
kleisliLeftIdentity 2
kleisliRightIdentity 2
mapFlatMapCoherence 2
<init> 0
apply 1
$init$ 0
F 0
monoidKLeftIdentity 1
monoidKRightIdentity 1
<init> 0
apply 1
$init$ 0
P 0
parallelRoundTrip 1
sequentialRoundTrip 1
isomorphicFunctor 2
<init> 0
apply 1
$init$ 0
F 0
nonEmptyTraverseIdentity 2
nonEmptyTraverseSequentialComposition 5
nonEmptyTraverseParallelComposition 5
reduceMapDerived 3
<init> 0
apply 1
$init$ 0
P 0
isomorphicPure 1
<init> 0
apply 1
$init$ 0
F 0
profunctorIdentity 1
profunctorComposition 5
profunctorLmapIdentity 1
profunctorRmapIdentity 1
profunctorLmapComposition 3
profunctorRmapComposition 3
<init> 0
apply 1
$init$ 0
F 0
reduceLeftToConsistentWithReduceMap 3
reduceRightToConsistentWithReduceMap 3
reduceRightToConsistentWithReduceRightToOption 3
reduceRightConsistentWithReduceRightOption 2
reduceReduceLeftConsistent 2
traverseConsistent 3
sequenceConsistent 2
sizeConsistent 1
<init> 0
apply 1
$init$ 0
F 0
semigroupKAssociative 3
<init> 0
apply 1
$init$ 0
F 0
semigroupalAssociativity 3
<init> 0
apply 1
$init$ 0
F 0
strongFirstDistributivity 3
strongSecondDistributivity 3
<init> 0
apply 1
$init$ 0
F 0
traverseIdentity 2
traverseSequentialComposition 5
traverseParallelComposition 5
foldMapDerived 3
traverseOrderConsistent 1
mapWithIndexRef 2
traverseWithIndexMRef 3
zipWithIndexRef 2
<init> 0
apply 1
$init$ 0
F 0
unorderedFoldConsistentWithUnorderedFoldMap 2
forallConsistentWithExists 2
existsLazy 1
forallLazy 1
forallEmpty 2
nonEmptyRef 1
<init> 0
apply 1
$init$ 0
F 0
unorderedTraverseIdentity 3
unorderedTraverseSequentialComposition 5
unorderedTraverseParallelComposition 5
unorderedSequenceConsistent 2
<init> 0
apply 1
$init$ 0
laws 0
alternative 16
<init> 0
apply 1
$init$ 0
laws 0
applicativeError 26
<init> 0
apply 1
$init$ 0
laws 0
applicative 16
<init> 0
apply 1
$init$ 0
laws 0
apply 15
<init> 0
apply 1
<init> 0
catsLawsCogenForTry 1
catsLawsCogenForFunction0 1
catsLawsArbitraryForConst 1
catsLawsCogenForConst 1
catsLawsArbitraryForOneAnd 2
catsLawsCogenForOneAnd 2
catsLawsArbitraryForNonEmptyVector 1
catsLawsCogenForNonEmptyVector 1
catsLawsArbitraryForZipVector 1
catsLawsArbitraryForZipList 1
catsLawsArbitraryForZipStream 1
catsLawsArbitraryForZipNonEmptyVector 1
catsLawsArbitraryForNonEmptyList 1
catsLawsCogenForNonEmptyList 1
catsLawsArbitraryForZipNonEmptyList 1
catsLawsArbitraryForEitherT 1
catsLawsCogenForEitherT 1
catsLawsArbitraryForValidated 2
catsLawsCogenForValidated 2
catsLawsArbitraryForIor 2
catsLawsCogenForIor 2
catsLawsArbitraryForIorT 1
catsLawsCogenForIorT 1
catsLawsArbitraryForOptionT 1
catsLawsCogenForOptionT 1
catsLawsArbitraryForIdT 1
catsLawsCogenForIdT 1
catsLawsArbitraryForEval 1
catsLawsCogenForEval 1
catsLawsArbitraryForTuple2K 2
catsLawsArbitraryForFunc 3
catsLawsArbitraryForAppFunc 4
catsLawsArbitraryForWriter 2
catsLawsCogenForWriter 2
catsLawsArbitraryForPartialFunction 1
catsLawsArbitraryForEitherK 2
catsLawsCogenForEitherK 2
catLawsCogenForTuple2K 2
catsLawsArbitraryForShow 1
catsLawsArbitraryForFn0 1
catsLawsArbitraryForEq 1
catsLawsArbitraryForEquiv 1
catsLawsArbitraryForPartialOrder 1
catsLawsArbitraryForPartialOrdering 1
catsLawsArbitraryForOrder 1
catsLawsArbitraryForSortedMap 3
catsLawsCogenForSortedMap 4
catsLawsArbitraryForSortedSet 2
catsLawsCogenForSortedSet 2
catsLawsArbitraryForOrdering 1
catsLawsArbitraryForHash 1
catsLawsArbitraryForNested 1
catsLawArbitraryForState 3
catsLawArbitraryForReader 3
catsLawArbitraryForCokleisliId 3
catsLawsArbitraryForIRWST 2
$init$ 0
catsLawArbitraryForIndexedStateT 1
catsLawsArbitraryForWriterT 1
catsLawsCogenForWriterT 1
catsLawsArbitraryForKleisli 3
catsLawsArbitraryForCokleisli 3
$init$ 0
laws 0
arrowChoice 39
<init> 0
apply 1
$init$ 0
laws 0
arrow 31
<init> 0
apply 1
$init$ 0
laws 0
bifoldable 8
<init> 0
apply 1
$init$ 0
laws 0
bifunctor 9
<init> 0
apply 1
$init$ 0
laws 0
bimonad 25
<init> 0
apply 1
$init$ 0
laws 0
bitraverse 25
<init> 0
apply 1
$init$ 0
laws 0
category 5
<init> 0
apply 1
$init$ 0
laws 0
choice 7
<init> 0
apply 1
$init$ 0
laws 0
coflatMap 14
<init> 0
apply 1
$init$ 0
laws 0
commutativeApplicative 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeApply 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeArrow 31
<init> 0
apply 1
$init$ 0
laws 0
commutativeFlatMap 20
<init> 0
apply 1
$init$ 0
laws 0
commutativeMonad 20
<init> 0
apply 1
$init$ 0
laws 0
comonad 17
<init> 0
apply 1
$init$ 0
laws 0
compose 4
<init> 0
apply 1
$init$ 0
laws 0
contravariantMonoidal 14
<init> 0
apply 1
$init$ 0
laws 0
contravariantSemigroupal 14
<init> 0
apply 1
$init$ 0
laws 0
contravariant 9
<init> 0
apply 1
$init$ 0
laws 0
distributive 20
<init> 0
apply 1
<init> 0
catsLawsEqForFn1 2
catsLawsEqForFn2 3
catsLawsEqForShow 1
sampledEq 4
catsLawsEqForEq 1
catsLawsEqForEquiv 1
catsLawsEqForPartialOrder 2
catsLawsEqForPartialOrdering 2
catsLawsEqForOrder 1
catsLawsEqForOrdering 1
catsLawsEqForHash 1
catsLawsEqForSemigroup 2
catsLawsEqForCommutativeSemigroup 2
catsLawsEqForBand 3
catsLawsEqForMonoid 2
catsLawsEqForSemilattice 3
catsLawsEqForCommutativeMonoid 3
catsLawsEqForBoundedSemilattice 3
catsLawsEqForGroup 3
catsLawsEqForCommutativeGroup 3
$init$ 0
laws 0
flatMap 16
<init> 0
apply 1
$init$ 0
laws 0
foldable 12
<init> 0
apply 1
$init$ 0
laws 0
functor 9
<init> 0
apply 1
$init$ 0
laws 0
injectK 4
<init> 0
apply 1
$init$ 0
laws 0
inject 4
<init> 0
apply 1
$init$ 0
laws 0
invariantMonoidal 14
<init> 0
apply 1
$init$ 0
laws 0
invariantSemigroupal 14
<init> 0
apply 1
$init$ 0
laws 0
invariant 9
<init> 0
apply 1
$init$ 0
laws 0
monadError 27
<init> 0
apply 1
$init$ 0
laws 0
monad 20
stackUnsafeMonad 20
<init> 0
apply 1
$init$ 0
laws 0
monoidK 3
<init> 0
apply 1
$init$ 0
laws 0
nonEmptyParallel 8
<init> 0
apply 1
$init$ 0
laws 0
nonEmptyTraverse 38
<init> 0
apply 1
$init$ 0
laws 0
parallel 8
<init> 0
apply 1
$init$ 0
laws 0
profunctor 16
<init> 0
apply 1
$init$ 0
laws 0
reducible 16
<init> 0
apply 1
$init$ 0
laws 0
semigroupK 3
<init> 0
apply 1
$init$ 0
laws 0
semigroupal 9
<init> 0
apply 2
associativity 1
leftIdentity 1
rightIdentity 1
<init> 0
invariant 1
$init$ 0
laws 0
strong 19
<init> 0
apply 1
$init$ 0
laws 0
traverse 30
<init> 0
apply 1
$init$ 0
laws 0
unorderedFoldable 9
<init> 0
apply 1
$init$ 0
laws 0
unorderedTraverse 19
<init> 0
apply 1
<init> 0
catsLawsIsEqToProp 3
<init> 0
<init> 1
$less$minus$greater 1
$init$ 0
laws 0
tailRecM 4
<init> 0
apply 1
<init> 1
areEquivalent 2
$init$ 0
lowPriorityCatsCanEqual 2
$init$ 0
convertToEqualizer 1
convertToCheckingEqualizer 1
unconstrainedEquality 1
catsCanEqual 2
<init> 0
$init$ 0
$init$ 0
catsSyntaxEq 2
even 1
$init$ 0
<init> 0
<init> 0
n 0
<init> 1
$init$ 0
<init> 1
<init> 1
<init> 0
<init> 1
<init> 0
<init> 0
partialCompare 2
<init> 1
<init> 0
<init> 0
compare 2
<init> 1
<init> 0
<init> 0
hash 1
eqv 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
<init> 1
<init> 0
<init> 0
empty 0
combine 2
inverse 1
<init> 1
<init> 0
<init> 0
empty 0
combine 2
inverse 1
